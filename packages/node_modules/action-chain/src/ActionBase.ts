import { ActionChain, ExecutionContext } from './ActionChain'

export class StopExecution {
  constructor(public value: any) {}
}
export class ActionBase<Effects> {
  static nextActionId: number = 0
  private currentExecutionId = 0
  constructor(
    private actionChain: ActionChain<Effects>,
    private initialActionId: number = ActionBase.nextActionId++,
    private runOperators?: (
      value: any,
      executionContext: ExecutionContext,
      newPath?: string
    ) => any | Promise<any>
  ) {
    interface I extends ActionBase<Effects> {
      (value: any): I
      displayName: string
    }
    this.getActionChain = this.getActionChain.bind(this)

    const instance: I = Object.assign(function(value) {
      const initialOperator = typeof arguments[1] === 'undefined'
      const newPath = typeof arguments[2] === 'undefined' ? null : arguments[2]
      const executionContext: ExecutionContext = initialOperator
        ? {
            __execution: {
              operatorId: -1,
              actionId: initialActionId,
              executionId: instance.currentExecutionId++,
            },
            __path: [],
          }
        : arguments[1]
      if (initialOperator) {
        actionChain.emit('action:start', {
          actionId: executionContext.__execution.actionId,
          executionId: executionContext.__execution.executionId,
          actionName: instance.displayName,
          value,
        })
      }
      const returnValue = runOperators
        ? runOperators(value, executionContext, newPath)
        : value

      if (initialOperator && returnValue instanceof Promise) {
        returnValue.then(() => {
          actionChain.emit('action:end', {
            actionId: executionContext.__execution.actionId,
            executionId: executionContext.__execution.executionId,
            actionName: instance.displayName,
          })
        })
      } else if (initialOperator) {
        actionChain.emit('action:end', {
          actionId: executionContext.__execution.actionId,
          executionId: executionContext.__execution.executionId,
          actionName: instance.displayName,
        })
      }

      return returnValue
    }, this) as any

    return instance
  }
  getActionChain<ExtraEvents = {}>() {
    return this.actionChain as ActionChain<Effects, ExtraEvents>
  }
  createOperatorResult = (
    type: string,
    name: string,
    cb: any
  ): [ActionChain<Effects>, number, any] => {
    return [
      this.actionChain,
      this.initialActionId,
      (props, executionContext, newPath) => {
        const executionContextWithPath = {
          __execution: executionContext.__execution,
          __path: newPath
            ? executionContext.__path.concat(newPath)
            : executionContext.__path.slice(),
        }
        const prevResult = this.runOperators
          ? this.runOperators(props, executionContextWithPath)
          : props

        const produceResult = (currentValue) => {
          if (currentValue instanceof StopExecution) {
            return currentValue
          }

          const thisExecution = {
            ...executionContextWithPath.__execution,
            operatorId: executionContextWithPath.__execution.operatorId + 1,
          }

          executionContextWithPath.__execution.operatorId++

          const path = executionContextWithPath.__path

          const effects = this.actionChain.getEffects(
            thisExecution,
            executionContextWithPath
          )

          this.actionChain.emit('operator:start', {
            type,
            name,
            path,
            ...thisExecution,
          })
          const result = cb(effects, currentValue)

          if (result instanceof Promise) {
            this.actionChain.emit('operator:async', {
              type,
              name,
              path,
              isAsync: true,
              ...thisExecution,
            })
            return result.then((promiseResult) => {
              this.actionChain.emit('operator:end', {
                type,
                name,
                path,
                ...thisExecution,
                isAsync: true,
                result: promiseResult,
              })
              return promiseResult
            })
          }

          this.actionChain.emit('operator:end', {
            type,
            name,
            path,
            ...thisExecution,
            isAsync: false,
            result: result,
          })

          return result
        }

        if (prevResult instanceof Promise) {
          return prevResult.then(produceResult)
        }

        return produceResult(prevResult)
      },
    ]
  }
}
