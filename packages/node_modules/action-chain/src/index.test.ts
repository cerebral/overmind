import {
  actionChainFactory,
  actionBaseFactory,
  ActionBase,
  NoValueActionBase,
  ActionChain,
  ExecutionContext,
} from './'

interface Operators<Context, InitialValue, Value> {
  test(
    cb: (value: Value, context: Context) => void
  ): [InitialValue] extends [void]
    ? NoValueAction<Context, InitialValue, Value>
    : Action<Context, InitialValue, Value>
  testFork(
    action: Action<Context, Value>
  ): [InitialValue] extends [void]
    ? NoValueAction<Context, InitialValue, Value>
    : Action<Context, InitialValue, Value>
}

export interface Action<Context, InitialValue, Value = InitialValue>
  extends Operators<Context, InitialValue, Value>,
    ActionBase<Context, InitialValue, Value> {}

export interface NoValueAction<Context, InitialValue, Value = InitialValue>
  extends Operators<Context, InitialValue, Value>,
    NoValueActionBase<Context, InitialValue, Value> {}

function actionFactory<Context, InitialValue, Value = InitialValue>(
  actionChain: ActionChain<Context>,
  initialActionId?: number,
  runOperators?: (
    value: any,
    executionContext: ExecutionContext
  ) => any | Promise<any>
): InitialValue extends undefined
  ? NoValueAction<Context, InitialValue, Value>
  : Action<Context, InitialValue, Value> {
  return Object.assign(
    actionBaseFactory<Context, InitialValue, Value>(
      actionChain,
      initialActionId,
      runOperators
    ) as any,
    {
      test(cb: (value: Value, context: Context) => void) {
        const operator = (value, context) => {
          return cb(value, context)
        }

        const [
          chain,
          initialActionId,
          runOperators,
        ] = this.createOperatorResult('test', cb.name, operator)

        return actionFactory<Context, InitialValue, Value>(
          chain,
          initialActionId,
          runOperators
        )
      },
      testFork(action: Action<Context, Value>) {
        const operator = (value, context) => {
          return (action as any)(value, context, 'fork')
        }

        const [
          chain,
          initialActionId,
          runOperators,
        ] = this.createOperatorResult('testFork', action.name, operator)

        return actionFactory<Context, InitialValue, Value>(
          chain,
          initialActionId,
          runOperators
        )
      },
    }
  )
}

class TestProvider {
  foo() {
    return 'bar'
  }
}

const context = {
  foo: {
    bar() {
      return 'baz'
    },
  },
  test: new TestProvider(),
}

type Context = typeof context

const actionChain = actionChainFactory<Context>(context)
const action = function<
  InitialValue = undefined
>(): InitialValue extends undefined
  ? NoValueAction<Context, InitialValue>
  : Action<Context, InitialValue> {
  return actionFactory<Context, InitialValue>(actionChain)
}

beforeEach(() => {
  ;(actionBaseFactory as any).nextActionId = 0
})

describe('VALUE', () => {
  test('should run and return result', () => {
    const test = action<string>()

    expect(test('foo')).toEqual('foo')
  })
})

describe('CONTEXT', () => {
  test('should pass default context', () => {
    expect.assertions(2)
    const test = action().test((_, { __execution, __path }: any) => {
      expect(__execution).toBeTruthy()
      expect(__path).toBeTruthy()
    })

    test()
  })

  test('should be able to extend context', () => {
    expect.assertions(1)
    const foo = action().test((_, { foo }) => {
      expect(foo.bar()).toBe('baz')
    })

    foo()
  })
})

describe('PROVIDER', () => {
  test('should track execution of providers', (done) => {
    expect.assertions(2)
    const foo = action().test((_, { foo }) => {
      expect(foo.bar()).toBe('baz')
    })

    actionChain.once('provider').then((task) => {
      expect(task).toEqual({
        operatorId: 0,
        actionId: 0,
        executionId: 0,
        method: 'bar',
        name: 'foo',
        result: 'baz',
      })
      done()
    })
    foo()
  })
  test('should track execution of class instance providers', (done) => {
    expect.assertions(2)
    const foo = action().test((_, { test }) => {
      expect(test.foo()).toBe('bar')
    })

    actionChain.once('provider').then((task) => {
      expect(task).toEqual({
        operatorId: 0,
        actionId: 0,
        executionId: 0,
        method: 'foo',
        name: 'test',
        result: 'bar',
      })
      done()
    })
    foo()
  })
})

describe('ACTION CHAIN', () => {
  test('should track execution', (done) => {
    expect.assertions(4)
    const foo = action().test(() => 'foo')

    actionChain.once('action:start').then((data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
      })
    })
    actionChain.once('operator:start').then((data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
        operatorId: 0,
        name: '',
        type: 'test',
        path: [],
      })
    })
    actionChain.once('operator:end').then((data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
        operatorId: 0,
        name: '',
        type: 'test',
        isAsync: false,
        path: [],
        result: 'foo',
      })
    })
    actionChain.once('action:end').then((data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
      })
      done()
    })

    foo()
  })
  test('should track async execution', (done) => {
    expect.assertions(2)
    const foo = () => {
      return Promise.resolve('foo')
    }
    const test = action().test(foo)

    actionChain.once('operator:start').then((task) => {
      expect(task).toEqual({
        actionId: 0,
        operatorId: 0,
        executionId: 0,
        name: 'foo',
        path: [],
        type: 'test',
      })
    })
    actionChain.once('operator:end').then((task) => {
      expect(task).toEqual({
        actionId: 0,
        operatorId: 0,
        executionId: 0,
        name: 'foo',
        path: [],
        type: 'test',
        isAsync: true,
        result: 'foo',
      })
      done()
    })

    return test()
  })
  test('should track path execution', (done) => {
    expect.assertions(4)
    const forkAction = action().test(() => Promise.resolve('foo'))
    const test = action().testFork(forkAction)

    const expectedFlow = [
      {
        event: 'operator:start',
        data: {
          actionId: 1,
          operatorId: 0,
          executionId: 0,
          name: '',
          path: [],
          type: 'testFork',
        },
      },
      {
        event: 'operator:start',
        data: {
          actionId: 1,
          operatorId: 1,
          executionId: 0,
          name: '',
          path: ['fork'],
          type: 'test',
        },
      },
      {
        event: 'operator:end',
        data: {
          actionId: 1,
          operatorId: 1,
          executionId: 0,
          name: '',
          path: ['fork'],
          type: 'test',
          isAsync: true,
          result: 'foo',
        },
      },
      {
        event: 'operator:end',
        data: {
          actionId: 1,
          operatorId: 0,
          executionId: 0,
          name: '',
          path: [],
          type: 'testFork',
          isAsync: true,
          result: 'foo',
        },
      },
    ]

    let eventCount = 0
    const unsubscribe = actionChain.onAny((event, data) => {
      if (event === 'operator:start' || event === 'operator:end') {
        expect({ event, data }).toEqual(expectedFlow[eventCount])
        eventCount++
        if (eventCount === expectedFlow.length) {
          unsubscribe()
          done()
        }
      }
    })
    return test()
  })
  test('should emit event when operator has async result', (done) => {
    expect.assertions(1)
    const test = action().test(() => Promise.resolve('foo'))

    actionChain.once('operator:async').then((task) => {
      expect(task).toEqual({
        actionId: 0,
        operatorId: 0,
        executionId: 0,
        name: '',
        path: [],
        isAsync: true,
        type: 'test',
      })
      done()
    })

    test()
  })
})
