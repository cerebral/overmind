import { ActionBase, ActionChain } from './'

interface IAction<Context, InitialValue, Value = InitialValue>
  extends Action<Context, InitialValue, Value> {
  (value: InitialValue): Value
}

interface INoValueAction<Context, InitialValue, Value = InitialValue>
  extends Action<Context, InitialValue, Value> {
  (): Value
}

class Action<Context, InitialValue, Value = InitialValue> extends ActionBase<
  Context
> {
  test: (
    cb: (context: Context, value: Value) => void
  ) => InitialValue extends void
    ? INoValueAction<Context, InitialValue, Value>
    : IAction<Context, InitialValue, Value> = (cb) => {
    const operator = (context, value) => {
      return cb(context, value)
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'test',
      cb.name,
      operator
    )

    return new Action(chain, initialActionId, runOperators) as any
  }
  testFork: (
    action: Action<Context, Value>
  ) => InitialValue extends void
    ? INoValueAction<Context, InitialValue, Value>
    : IAction<Context, InitialValue, Value> = (action) => {
    const operator = (context, value) => {
      return (action as any)(value, context, 'fork')
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'testFork',
      '',
      operator
    )

    return new Action(chain, initialActionId, runOperators) as any
  }
}

class TestProvider {
  foo() {
    return 'bar'
  }
}

const context = {
  foo: {
    bar() {
      return 'baz'
    },
    nestedProvider: {
      bar() {
        return 'baz'
      },
    },
  },
  test: new TestProvider(),
}

type Context = typeof context

const actionChain = new ActionChain<Context>(context)

// FORCE SYNC EVENTS
actionChain.emitAsync = actionChain.emit.bind(actionChain)

const action: <InitialValue = void>() => InitialValue extends void
  ? INoValueAction<Context, InitialValue>
  : IAction<Context, InitialValue> = () => {
  return new Action(actionChain) as any
}

beforeEach(() => {
  ActionBase.nextActionId = 0
})

describe('ACTION', () => {
  test('should be able to give the action a name', () => {
    expect.assertions(1)
    const test = action() as any
    test.displayName = 'My Name'
    actionChain.once('action:start', (execution) => {
      expect(execution.actionName).toEqual('My Name')
    })
    test()
  })
})

describe('VALUE', () => {
  test('should run and return result', () => {
    const test = action<string>()

    expect(test('foo')).toEqual('foo')
  })
})

describe('CONTEXT', () => {
  test('should pass default context', () => {
    expect.assertions(2)
    const test = action().test(({ __execution, __path }: any) => {
      expect(__execution).toBeTruthy()
      expect(__path).toBeTruthy()
    })

    test()
  })

  test('should be able to extend context', () => {
    expect.assertions(1)
    const fn = action().test(({ foo }) => {
      expect(foo.bar()).toBe('baz')
    })

    fn()
  })
})

describe('EFFECTS', () => {
  test('should track execution of effects', () => {
    expect.assertions(2)
    const fn = action().test(({ foo }) => {
      expect(foo.bar()).toBe('baz')
    })

    actionChain.once('effect', (task) => {
      expect(task).toEqual({
        operatorId: 0,
        actionId: 0,
        executionId: 0,
        method: 'bar',
        name: 'foo',
        args: [],
        result: 'baz',
      })
    })
    fn()
  })
  test('should track execution of namespaced effects', () => {
    expect.assertions(2)
    const fn = action().test(({ foo }) => {
      expect(foo.nestedProvider.bar()).toBe('baz')
    })

    actionChain.once('effect', (task) => {
      expect(task).toEqual({
        operatorId: 0,
        actionId: 0,
        executionId: 0,
        method: 'bar',
        name: 'foo.nestedProvider',
        args: [],
        result: 'baz',
      })
    })
    fn()
  })
  test('should track execution of class instance effects', () => {
    expect.assertions(2)
    const fn = action().test(({ test }) => {
      expect(test.foo()).toBe('bar')
    })

    actionChain.once('effect', (task) => {
      expect(task).toEqual({
        operatorId: 0,
        actionId: 0,
        executionId: 0,
        method: 'foo',
        args: [],
        name: 'test',
        result: 'bar',
      })
    })
    fn()
  })
})

describe('ACTION CHAIN', () => {
  test('should track execution', () => {
    expect.assertions(4)
    const fn = action().test(() => 'foo')

    actionChain.once('action:start', (data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
      })
    })
    actionChain.once('operator:start', (data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
        operatorId: 0,
        name: '',
        type: 'test',
        path: [],
      })
    })
    actionChain.once('operator:end', (data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
        operatorId: 0,
        name: '',
        type: 'test',
        isAsync: false,
        path: [],
        result: 'foo',
      })
    })
    actionChain.once('action:end', (data) => {
      expect(data).toEqual({
        actionId: 0,
        executionId: 0,
      })
    })

    fn()
  })
  test('should track async execution', () => {
    expect.assertions(2)
    const foo = () => {
      return Promise.resolve('foo')
    }
    const test = action().test(foo)

    actionChain.once('operator:start', (task) => {
      expect(task).toEqual({
        actionId: 0,
        operatorId: 0,
        executionId: 0,
        name: 'foo',
        path: [],
        type: 'test',
      })
    })
    actionChain.once('operator:end', (task) => {
      expect(task).toEqual({
        actionId: 0,
        operatorId: 0,
        executionId: 0,
        name: 'foo',
        path: [],
        type: 'test',
        isAsync: true,
        result: 'foo',
      })
    })

    return test()
  })
  test('should track path execution', () => {
    expect.assertions(4)
    const forkAction = action().test(() => Promise.resolve('foo'))
    const test = action().testFork(forkAction)

    actionChain.once('operator:start', (task) => {
      expect(task).toEqual({
        actionId: 1,
        operatorId: 0,
        executionId: 0,
        name: '',
        path: [],
        type: 'testFork',
      })
      actionChain.once('operator:start', (task) => {
        expect(task).toEqual({
          actionId: 1,
          operatorId: 1,
          executionId: 0,
          name: '',
          path: ['fork'],
          type: 'test',
        })
      })
    })
    actionChain.once('operator:end', (task) => {
      expect(task).toEqual({
        actionId: 1,
        operatorId: 1,
        executionId: 0,
        name: '',
        path: ['fork'],
        type: 'test',
        isAsync: true,
        result: 'foo',
      })
      actionChain.once('operator:end', (task) => {
        expect(task).toEqual({
          actionId: 1,
          operatorId: 0,
          executionId: 0,
          name: '',
          path: [],
          type: 'testFork',
          isAsync: true,
          result: 'foo',
        })
      })
    })

    return test()
  })
  test('should emit event when operator has async result', () => {
    expect.assertions(1)
    const test = action().test(() => Promise.resolve('foo'))

    actionChain.once('operator:async', (task) => {
      expect(task).toEqual({
        actionId: 0,
        operatorId: 0,
        executionId: 0,
        name: '',
        path: [],
        isAsync: true,
        type: 'test',
      })
    })

    return test()
  })
})
