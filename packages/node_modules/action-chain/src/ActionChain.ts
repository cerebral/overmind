import { Typed as Emittery } from 'emittery'

const IS_DEVELOPMENT = process.env.NODE_ENV !== 'production'

export type ActionChainEvents =
  | 'provider'
  | 'action:start'
  | 'action:end'
  | 'operator:start'
  | 'operator:end'
  | 'operator:async'

export type ExecutionContext = {
  __execution: Execution
  __path: string[]
}

export interface ActionChain<Context> extends Emittery<any, ActionChainEvents> {
  getOptions(): ActionChainOptions
  getContext(executionContext: ExecutionContext): Context & ExecutionContext
}

export type ActionChainOptions = {
  actionWrapper?: any
  providerExceptions?: string[]
}

export type Execution = {
  operatorId: number
  actionId: number
  executionId: number
}

export function actionChainFactory<Context>(
  context: Context,
  options: ActionChainOptions = {}
): ActionChain<Context> {
  options.providerExceptions = options.providerExceptions || []

  return Object.assign(new Emittery<any, ActionChainEvents>(), {
    getOptions() {
      return options
    },
    getContext(executionContext: ExecutionContext) {
      const instance = this
      const providers = Object.keys(context).reduce((currentContext, key) => {
        if (IS_DEVELOPMENT && options.providerExceptions.indexOf(key) === -1) {
          currentContext[key] = new Proxy(context[key], {
            get(target, prop) {
              if (typeof target[prop] === 'function') {
                return (...args) => {
                  const result = target[prop](...args)
                  if (result instanceof Promise) {
                    result.then((promisedResult) => {
                      instance.emit('provider', {
                        ...executionContext.__execution,
                        name: key,
                        method: prop,
                        result: promisedResult,
                      })
                    })
                  } else {
                    instance.emit('provider', {
                      ...executionContext.__execution,
                      name: key,
                      method: prop,
                      result,
                    })
                  }

                  return result
                }
              }

              return target[prop]
            },
          })
        } else {
          currentContext[key] = context[key]
        }

        return currentContext
      }, {})

      return Object.assign({}, providers, executionContext) as Context &
        ExecutionContext
    },
  })
}
