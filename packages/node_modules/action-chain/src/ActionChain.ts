import { EventEmitter } from 'betsy'
import { Mutation } from 'proxy-state-tree'

const IS_DEVELOPMENT = process.env.NODE_ENV !== 'production'

export type ExecutionContext = {
  __execution: Execution
  __path: string[]
}

export type ActionChainOptions = {
  actionWrapper?: any
  providerExceptions?: string[]
}

export type Execution = {
  operatorId: number
  actionId: number
  executionId: number
}

export type ActionExecution = {
  actionId: number
  executionId: number
  actionName: string
  value?: any
}

export type OperatorExecution = {
  actionId: number
  executionId: number
  operatorId: number
  type: string
  name: string
  path: string
}

export interface ActionChainEvents {
  effect: Execution & {
    name: string
    method: string | number | symbol
    result: any
    args: any[]
  }
  'action:start': ActionExecution
  'action:end': ActionExecution
  'operator:start': OperatorExecution
  'operator:async': OperatorExecution & {
    isAsync: boolean
  }
  'operator:end': OperatorExecution & {
    isAsync: boolean
    result: any
  }
  mutations: ActionExecution & {
    mutations: Mutation[]
  }
}

function isObject(value) {
  return typeof value === 'object' && !Array.isArray(value) && value !== null
}

export class ActionChain<Effects> extends EventEmitter<ActionChainEvents> {
  constructor(
    private effects: Effects,
    private options: ActionChainOptions = {}
  ) {
    super()
    this.options.providerExceptions = options.providerExceptions || []
  }
  private createGetHandler(execution, path) {
    const instance = this
    return (target, prop) => {
      if (typeof target[prop] === 'function') {
        return (...args) => {
          const result = target[prop](...args)
          if (result instanceof Promise) {
            result.then((promisedResult) => {
              instance.emitAsync('effect', {
                ...execution,
                name: path,
                method: prop,
                args,
                result: promisedResult,
              })
            })
          } else {
            instance.emitAsync('effect', {
              ...execution,
              name: path,
              method: prop,
              args,
              result,
            })
          }

          return result
        }
      } else if (isObject(target[prop])) {
        return new Proxy(target[prop], {
          get: instance.createGetHandler(execution, path + '.' + prop),
        })
      }

      return target[prop]
    }
  }

  getEffects(thisExecution: Execution, executionContext: ExecutionContext) {
    let effects = this.effects

    if (IS_DEVELOPMENT) {
      effects = Object.keys(this.effects).reduce((currentEffects, key) => {
        if (
          this.options.providerExceptions.indexOf(key) === -1 &&
          isObject(this.effects[key])
        ) {
          currentEffects[key] = new Proxy(this.effects[key], {
            get: this.createGetHandler(thisExecution, key),
          })
        } else {
          currentEffects[key] = this.effects[key]
        }

        return currentEffects
      }, {}) as Effects
    }

    return Object.assign({}, effects, executionContext)
  }
}
