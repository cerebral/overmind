import { Derive } from 'overmind'
import {
  Action,
  App,
  Apps,
  Component,
  Flush,
  GroupedComponents,
  Tab,
  AppMessageType,
  HistoryRecord,
  ExecutionType,
  MutationsMessage,
  HistoryRecordType,
  MutationHistoryRecord,
  FlushMessage,
  FlushHistoryRecord,
  EffectMessage,
  EffectHistoryRecord,
} from './types'

type State = {
  isConnecting: boolean
  error: string
  port: string
  apps: Apps
  currentAppName: string
  newPortValue: string
  currentTab: Tab
  showApps: boolean
  currentAction: Derive<State, Action>
  currentApp: App
  componentsMounted: Derive<State, Component[]>
  componentsUpdateCount: Derive<State, number>
  componentsStatePathCount: Derive<State, number>
  flushes: Derive<State, Flush[]>
  flushesMutationsCount: Derive<State, number>
  flushesStatePathCount: Derive<State, number>
  groupedComponents: Derive<State, GroupedComponents>
  history: Derive<State, HistoryRecord[]>
}

const state: State = {
  isConnecting: true,
  error: null,
  showApps: false,
  currentAppName: null,
  port: '3031',
  apps: {},
  newPortValue: '',
  currentTab: Tab.State,
  get currentApp() {
    const state: State = this

    return state.apps[state.currentAppName]
  },
  componentsMounted: (state) =>
    Object.keys(state.currentApp.components).reduce(
      (aggr, key) => {
        if (state.currentApp.components[key].isMounted) {
          return aggr.concat(state.currentApp.components[key])
        }

        return aggr
      },
      [] as Component[]
    ),
  componentsUpdateCount: (state) =>
    state.componentsMounted.reduce(
      (aggr, component) => aggr + component.updateCount,
      0
    ),
  componentsStatePathCount: (state) =>
    state.componentsMounted.reduce(
      (aggr, component) => aggr + component.paths.length,
      0
    ),
  flushes: (state) =>
    Object.keys(state.currentApp.flushes)
      .sort(
        (idA, idB) =>
          state.currentApp.flushes[idB].flushId -
          state.currentApp.flushes[idA].flushId
      )
      .map((id) => state.currentApp.flushes[id]),
  flushesMutationsCount: (state) =>
    state.flushes.reduce((aggr, flush) => aggr + flush.mutations.length, 0),
  flushesStatePathCount: (state) =>
    state.flushes.reduce((aggr, flush) => {
      return flush.mutations.reduce(
        (aggr, mutation) =>
          aggr.includes(mutation.path) ? aggr : aggr.concat(mutation.path),
        aggr
      )
    }, []).length,
  currentAction: (state) =>
    state.currentApp.actions[state.currentApp.currentActionId],
  groupedComponents(state) {
    const components = state.componentsMounted

    return components.reduce(
      (aggr, component) => {
        if (aggr[component.name]) {
          aggr[component.name].components.push(component)
        } else {
          aggr[component.name] = {
            name: component.name,
            components: [component],
            isCollapsed: !state.currentApp.expandedComponents.includes(
              component.name
            ),
          }
        }

        return aggr
      },
      {} as GroupedComponents
    )
  },
  history: (state) => {
    return state.currentApp.messages.reduce((aggr, message) => {
      switch (message.type) {
        case ExecutionType.MUTATIONS:
          const mutationsMessage = message as MutationsMessage

          return aggr.concat(
            mutationsMessage.data.mutations.map((mutation) => {
              const mutationRecord: MutationHistoryRecord = {
                type: HistoryRecordType.Mutation,
                data: mutation,
              }

              return mutationRecord
            })
          )
        case ExecutionType.FLUSH:
          const flushMessage = message as FlushMessage
          const flushRecord: FlushHistoryRecord = {
            type: HistoryRecordType.Flush,
            data: state.currentApp.flushes[flushMessage.data.flushId],
          }

          return aggr.concat(flushRecord)
        case ExecutionType.EFFECT:
          const effectMessage = message as EffectMessage
          const effectRecord: EffectHistoryRecord = {
            type: HistoryRecordType.Effect,
            data: effectMessage.data,
          }

          return aggr.concat(effectRecord)
      }

      return aggr
    }, [])
  },
}

export default state
