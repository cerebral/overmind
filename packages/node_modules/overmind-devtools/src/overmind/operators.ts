import { Operator, action, forEach, fork, when, map } from 'overmind'
import {
  Message,
  AppMessage,
  InitMessage,
  FlushMessage,
  AddComponentMessage,
  UpdateComponentMessage,
  RemoveComponentMessage,
  DerivedMessage,
  DirtyDerivedMessage,
  ActionsListItemType,
  ActionItem,
  ActionGroupItem,
  StartActionMessage,
  StartOperatorMessage,
  EndOperatorMessage,
  EndActionMessage,
  MutationsMessage,
  EffectMessage,
  ExecutionType,
  AsyncOperatorMessage,
  EventType,
  Effect,
  GetterMessage,
} from './types'
import {
  createApp,
  ensureFlushExists,
  getActionId,
  getOperatorId,
  runMutation,
} from './utils'

export const ensureCurrentApp: Operator<Message> = action(
  ({ value: message, state }) => {
    if (!state.currentAppName) {
      state.currentAppName = message.appName
    }
  }
)

export const runGetterMutation: Operator<GetterMessage> = action(
  ({ value: message, state }) => {
    runMutation(state.apps[message.appName].state)({
      method: 'set',
      path: message.data.path,
      args: [message.data.value],
    })
  }
)

export const setPortExists: Operator<any> = action(({ state }) => {
  state.error = 'PORT_EXISTS'
})

export const isPortExistsMessage: (
  paths: {
    true: Operator<Message, any>
    false: Operator<Message, any>
  }
) => Operator<Message> = (paths) =>
  when(
    ({ value: message }) => message.messages[0].type === 'PORT_EXISTS',
    paths
  )

export const addState: Operator<InitMessage> = action(
  ({ value: message, state }) => {
    state.isConnecting = false
    state.apps[message.appName].state = message.data.state
  }
)

export const addFlushAndRunMutations: Operator<FlushMessage> = action(
  ({ value: message, state }) => {
    ensureFlushExists(state.apps[message.appName].flushes, message.data.flushId)
    state.apps[message.appName].flushes[message.data.flushId].mutations =
      message.data.mutations

    if (typeof message.data.operatorId === 'undefined') {
      state.apps[message.appName].flushByActionId[getActionId(message.data)] = {
        flushId: message.data.flushId,
      }
    } else {
      state.apps[message.appName].flushByOperatorId[
        getOperatorId(message.data)
      ] = {
        flushId: message.data.flushId,
      }
    }

    message.data.mutations.forEach(
      runMutation(state.apps[message.appName].state)
    )
  }
)

export const ensureApp: Operator<Message> = action(
  ({ value: message, state }) => {
    if (
      !state.apps[message.appName] ||
      message.messages[0].type === ExecutionType.INIT
    ) {
      state.apps[message.appName] = createApp({
        name: message.appName,
      })
    }
  }
)

export const addClientMessages: Operator<Message> = action(
  ({ value: message, state }) => {
    state.apps[message.appName].messages = JSON.parse(
      JSON.stringify(message.messages)
    )
      .reverse()
      .concat(state.apps[message.appName].messages)
  }
)

export const addComponent: Operator<AddComponentMessage> = action(
  ({ value: message, state }) => {
    const id = `${message.data.componentId}_${message.data.componentInstanceId}`

    state.apps[message.appName].components[id] = {
      id,
      isMounted: true,
      updateCount: 0,
      name: message.data.name,
      paths: message.data.paths,
    }
  }
)

export const updateComponent: Operator<UpdateComponentMessage> = action(
  ({ value: message, state }) => {
    const id = `${message.data.componentId}_${message.data.componentInstanceId}`

    state.apps[message.appName].components[id].paths = message.data.paths

    if ('flushId' in message.data) {
      state.apps[message.appName].components[id].updateCount++

      ensureFlushExists(
        state.apps[message.appName].flushes,
        message.data.flushId
      )

      state.apps[message.appName].flushes[message.data.flushId].components.push(
        id
      )
    }
  }
)

export const removeComponent: Operator<RemoveComponentMessage> = action(
  ({ value: message, state }) => {
    const id = `${message.data.componentId}_${message.data.componentInstanceId}`

    state.apps[message.appName].components[id].isMounted = false
  }
)

export const updateDerived: Operator<DerivedMessage> = action(
  ({ value: message, state }) => {
    const appState = state.apps[message.appName].state
    const path = message.data.path.split('.')
    const key = path.pop()
    const target = path.reduce((aggr, pathKey) => aggr[pathKey], appState)
    target[key] = message.data.value

    state.apps[message.appName].derived[message.data.path] = message.data
  }
)

export const updateFlushWithDerived: Operator<DirtyDerivedMessage> = action(
  ({ value: message, state }) => {
    ensureFlushExists(state.apps[message.appName].flushes, message.data.flushId)
    state.apps[message.appName].flushes[message.data.flushId].derived.push(
      message.data.path
    )
  }
)

export const addAction: Operator<StartActionMessage> = action(
  ({ value: message, state }) => {
    const app = state.apps[message.appName]
    const action = message.data
    const actionId = getActionId(action)
    const isSelectingFirstAction =
      !app.currentActionId || app.currentActionId === app.actionsList[0].id

    app.actions[actionId] = {
      ...action,
      isRunning: true,
      operators: [],
      hasError: false,
    }

    if (
      !app.actionsList.length ||
      app.actionsList[0].actionId !== action.actionId
    ) {
      app.actionsList.unshift({
        type: ActionsListItemType.ACTION,
        id: actionId,
        actionId: action.actionId,
      })
    } else if (app.actionsList[0].type === ActionsListItemType.ACTION) {
      const existingId = (app.actionsList[0] as ActionItem).id
      app.actionsList[0] = {
        type: ActionsListItemType.GROUP,
        id: getActionId(action),
        actionId: action.actionId,
        isCollapsed: true,
        actionIds: [actionId, existingId],
      }
    } else if (app.actionsList[0].type === ActionsListItemType.GROUP) {
      ;(app.actionsList[0] as ActionGroupItem).actionIds.unshift(actionId)
      ;(app.actionsList[0] as ActionGroupItem).id = actionId
    }

    if (isSelectingFirstAction) {
      app.currentActionId = actionId
    }
  }
)

export const addOperator: Operator<StartOperatorMessage> = action(
  ({ value: message, state }) => {
    const operatorData = message.data
    const actionId = getActionId(operatorData)
    const action = state.apps[message.appName].actions[actionId]
    const operator = {
      ...operatorData,
      isRunning: true,
      isCollapsed: true,
      events: [],
    }

    action.operators.push(operator)

    /*
    This ensures the order of operators, as actions composed with
    "parallel" operator can trigger operators sync/async, adding
    them in wrong order
  */
    const paths = new Map()
    action.operators.forEach((operator, index) => {
      const path = operator.path.length ? operator.path.join('.') : '__' + index
      if (paths.has(path)) {
        paths.get(path).push(operator)
      } else {
        paths.set(path, [operator])
      }
    })
    action.operators = Array.from(paths).reduce(
      (aggr, arr) => aggr.concat(arr[1]),
      []
    )
  }
)

export const updateOperator: Operator<EndOperatorMessage> = action(
  ({ value: message, state }) => {
    const operatorData = message.data
    const actionId = getActionId(operatorData)
    const action = state.apps[message.appName].actions[actionId]
    const operator = action.operators.find(
      (operator) => getOperatorId(operatorData) === getOperatorId(operator)
    )

    operator.isAsync = operatorData.isAsync
    operator.isRunning = false
    operator.result = operatorData.result
  }
)

export const updateAction: Operator<EndActionMessage> = action(
  ({ value: message, state }) => {
    const app = state.apps[message.appName]
    const action = message.data
    const id = `${action.actionId}_${action.executionId}`

    app.actions[id].isRunning = false
  }
)

export const addMutations: Operator<MutationsMessage> = action(
  ({ value: message, state }) => {
    const mutations = message.data
    const id = `${mutations.actionId}_${mutations.executionId}`
    const operator =
      state.apps[message.appName].actions[id].operators[mutations.operatorId]

    operator.events = operator.events.concat(
      mutations.mutations.map((mutation) => ({
        type: EventType.Mutation,
        data: mutation,
      }))
    )
  }
)

export const updateEffect: Operator<EffectMessage> = action(
  ({ value: message, state }) => {
    const effect = message.data
    const id = getActionId(effect)
    const action = state.apps[message.appName].actions[id]
    const operator =
      state.apps[message.appName].actions[id].operators[effect.operatorId]
    const existingEvent = operator.events.find(
      (event) =>
        event.type === EventType.Effect &&
        (event.data as Effect).effectId === effect.effectId
    )

    if (existingEvent) {
      Object.assign(existingEvent.data, effect)
    } else {
      operator.events.push({
        type: EventType.Effect,
        data: effect,
      })
    }

    if (effect.error) {
      action.hasError = true
    }
  }
)

export const getMessages: Operator<Message, AppMessage<any>[]> = map(
  ({ value }) =>
    value.messages.map((message) => ({ ...message, appName: value.appName }))
)

export const forkEachMessage: (
  paths: {
    [key: string]: Operator<AppMessage<any>, any>
  }
) => Operator<AppMessage<any>[]> = (paths) =>
  forEach(fork(({ value }) => value.type, paths) as Operator<AppMessage<any>>)

export const updateOperatorAsync: Operator<AsyncOperatorMessage> = action(
  () => {}
)
