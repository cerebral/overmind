import { Apps, State, Message, Tab } from './state'
import { runMutation } from './utils'

export const setApps = (apps: Apps, state: State) => (state.apps = apps || {})

export const setCurrentPort = (currentPort: string, state: State) => {
  if (currentPort) {
    state.currentPort = currentPort
  } else if (Object.keys(state.apps).length) {
    state.currentPort = Object.keys(state.apps)[0]
  }
}

export const setError = (error: string, state: State) => (state.error = error)

export const setAppLoaded = (_, state: State) => (state.isLoading = false)

export const setNewPortValue = (value: string, state: State) =>
  (state.newPortValue = value)

export const addNewApp = (_, state: State) =>
  (state.apps[state.newPortValue] = {
    name: null,
    port: state.newPortValue,
    messages: [],
    state: {},
    components: {},
    flushes: [
      {
        mutations: [],
        components: [],
      },
    ],
  })

export const resetNewPortValue = (_, state: State) => (state.newPortValue = '')

export const addMessagesFromClient = (message: Message, state: State) => {
  state.apps[message.port].messages = state.apps[message.port].messages.concat(
    message.message
  )
}

export const openState = (_, state: State) => (state.currentTab = Tab.State)

export const openConsole = (_, state: State) => (state.currentTab = Tab.Console)

export const openComponents = (_, state: State) =>
  (state.currentTab = Tab.Components)

export const toggleExpandStatePath = (path: string[], state: State) => {
  const pathString = path.join('.')

  if (state.expandedStatePaths.indexOf(pathString) >= 0) {
    state.expandedStatePaths.splice(
      state.expandedStatePaths.indexOf(pathString),
      1
    )
  } else {
    state.expandedStatePaths = state.expandedStatePaths.concat(pathString)
  }
}

export const performMutationsByMessageType = (
  message: Message,
  state: State
) => {
  message.message.forEach((clientMessage) => {
    switch (clientMessage.type) {
      case 'init': {
        state.apps[message.port].state = clientMessage.data.state
        break
      }
      case 'flush': {
        state.apps[message.port].flushes.push({
          mutations: clientMessage.data.mutations,
          components: [],
        })
        clientMessage.data.mutations.forEach(
          runMutation(state.apps[message.port].state)
        )
        break
      }
      case 'component:add': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.port].components[id] = {
          id,
          isMounted: true,
          updateCount: 0,
          ...clientMessage.data,
        }
        state.apps[message.port].flushes[
          state.apps[message.port].flushes.length - 1
        ].components.push(id)
        break
      }
      case 'component:update': {
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.port].components[id].paths = clientMessage.data.paths
        state.apps[message.port].components[id].updateCount++
        state.apps[message.port].flushes[
          state.apps[message.port].flushes.length - 1
        ].components.push(id)
        break
      }
      case 'component:remove':
        const id = `${clientMessage.data.componentId}_${
          clientMessage.data.componentInstanceId
        }`

        state.apps[message.port].components[id].isMounted = false
        state.apps[message.port].flushes[
          state.apps[message.port].flushes.length - 1
        ].components.push(id)
        break
    }
  })
}
