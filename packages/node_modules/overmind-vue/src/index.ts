import { EventType, IConfiguration, MODE_SSR, Overmind } from 'overmind'
import { Component, ComponentOptions, defineComponent, provide, Ref, h, inject, ref, onBeforeUpdate, onRenderTracked, onMounted, onBeforeUnmount } from 'vue'

type AnyComponent = ComponentOptions | Component

const OVERMIND = Symbol('OVERMIND')
const IS_PRODUCTION = process.env.NODE_ENV === 'production'

let nextComponentId = 0

function createMixin(overmind, propsCallback, trackPropsCallback = false) {
  const componentId = nextComponentId++
  let componentInstanceId = 0

  return {
    beforeCreate(this: any) {
      if (overmind.mode.mode === MODE_SSR) {
        this.overmind = {
          state: overmind.state,
          actions: overmind.actions,
          effects: overmind.effects,
          addMutationListener: overmind.addMutationListener,
          reaction: overmind.reaction,
        }
        if (propsCallback) {
          Object.assign(
            this,
            propsCallback({
              state: overmind.state,
              actions: overmind.actions,
              effects: overmind.effects,
            })
          )
        }
      } else {
        this[OVERMIND] = {
          tree: (overmind as any).proxyStateTree.getTrackStateTree(),
          componentInstanceId: componentInstanceId++,
          onUpdate: (mutations, paths, flushId) => {
            this[OVERMIND].currentFlushId = flushId
            this[OVERMIND].isUpdating = true
            this.$forceUpdate()
          },
          isUpdating: false,
        }
        this.overmind = {
          state: this[OVERMIND].tree.state,
          actions: overmind.actions,
          effects: overmind.effects,
          addMutationListener: overmind.addMutationListener,
          reaction: overmind.reaction,
        }

        this[OVERMIND].tree.track(this[OVERMIND].onUpdate)

        if (propsCallback) {
          Object.assign(
            this,
            propsCallback({
              state: this[OVERMIND].tree.state,
              actions: overmind.actions,
              effects: overmind.effects,
            })
          )
        }
      }
    },
    beforeUpdate(this: any) {
      if (overmind.mode.mode === MODE_SSR) return

      this[OVERMIND].tree.track(this[OVERMIND].onUpdate)

      if (propsCallback && trackPropsCallback) {
        Object.assign(
          this,
          propsCallback({
            state: this[OVERMIND].tree.state,
            actions: overmind.actions,
            effects: overmind.effects,
          })
        )
      }
    },
    ...(IS_PRODUCTION
      ? {
          updated(this: any) {
            this[OVERMIND].tree.stopTracking()
          },
        }
      : {
          mounted(this: any) {
            if (overmind.mode.mode === MODE_SSR) return

            overmind.eventHub.emitAsync(EventType.COMPONENT_ADD, {
              componentId,
              componentInstanceId: this[OVERMIND].componentInstanceId,
              name: this.$options.name || '',
              paths: Array.from(this[OVERMIND].tree.pathDependencies) as any,
            })
          },
          updated(this: any) {
            if (overmind.mode.mode === MODE_SSR) return

            this[OVERMIND].tree.stopTracking()

            if (this[OVERMIND].isUpdating) {
              overmind.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
                componentId,
                componentInstanceId: this[OVERMIND].componentInstanceId,
                name: this.$options.name || '',
                flushId: this[OVERMIND].currentFlushId,
                paths: Array.from(this[OVERMIND].tree.pathDependencies) as any,
              })
              this[OVERMIND].isUpdating = false
            }
          },
        }),
    beforeDestroy(this: any) {
      if (overmind.mode.mode === MODE_SSR) return

      // @ts-ignore
      overmind.proxyStateTree.disposeTree(this[OVERMIND].tree)
      if (IS_PRODUCTION) {
        return
      }

      overmind.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
        componentId,
        componentInstanceId: this[OVERMIND].componentInstanceId,
        name: this.$options.name || '',
      })
    },
  }
}

export const createPlugin = (overmind) => ({
  install(
    Vue,
    propsCallback = ({ state, actions, effects }) => ({
      state,
      actions,
      effects,
    })
  ) {
    Vue.mixin(createMixin(overmind, propsCallback))
  },
})



export function createConnect<Config extends IConfiguration>(overmind: Overmind<Config>) {
  return <T extends {}>(cb: ((overmind: Overmind<Config>) => T) | AnyComponent, component?: AnyComponent) => {
    let options: any = component || cb
    let propsCallback = component ? cb : null

    if (propsCallback && typeof propsCallback !== 'function') {
      throw new Error(
        `OVERMIND-VUE: When passing two arguments to "connect", the first has to be a function. You can alternatively only pass a single argument, which is the component`
      )
    }

    return {
      ...options,
      mixins: (options.mixins ? options.mixins : []).concat(
        createMixin(overmind, propsCallback, true)
      ),
      overmind,
    } as any
  }
}

export const withOvermind = (instance: Overmind<IConfiguration>, Component: Component) => {
  return defineComponent({
    setup() {
      provide('overmind', instance)
    },
    render() {
      return h(Component)
    }
  })
}

export interface StateHook<Config extends IConfiguration> {
  (): Ref<Overmind<Config>["state"]>;
  <CB extends (state: Overmind<Config>["state"]) => object>(cb: CB): CB extends (state: Overmind<Config>["state"]) => infer O ? O extends object ? Ref<O> : never : never;
}

export function createStateHook<Config extends IConfiguration>(): StateHook<Config> {
  const componentId = nextComponentId++
  let componentInstanceId = 0
  return ((cb: any) => {
    const overmindInstance = inject<any>('overmind')

    if (overmindInstance.mode.mode === MODE_SSR) {
      return cb ? cb(overmindInstance.state) : overmindInstance.state
    } else {
      const overmindRef = ref<any>({})
      const flushIds = ref(-1)
      const { value } = overmindRef
      const state = ref(cb ? cb(overmindInstance.state) : overmindInstance.state)

      if (!value.tree) {
        value.tree = overmindInstance.proxyStateTree.getTrackStateTree()
        value.componentInstanceId = componentInstanceId++
        value.onUpdate = (_: any, __: any, flushId: number) => {
          value.currentFlushId = flushId
          value.isUpdating = true
          flushIds.value = flushId
          state.value = {
            ...(cb ? cb(overmindInstance.state) : overmindInstance.state)
          }

          // this.$forceUpdate()
        }
        value.isUpdating = false
      }

      onBeforeUpdate(function (this: any, ...args) {
        if (overmindInstance.mode.mode === MODE_SSR) return

        value.tree.track(value.onUpdate)
      })

      onRenderTracked(function (this: any, ...args) {
        

        if (IS_PRODUCTION) {
          return
        }

        if (overmindInstance.isUpdating) {
            overmindInstance.eventHub.emitAsync(EventType.COMPONENT_UPDATE, {
              componentId,
              componentInstanceId: value.componentInstanceId,
              name: '', // this.$options.name || '',
              flushId: value.currentFlushId,
              paths: Array.from(value.tree.pathDependencies) as any,
            })
            value.isUpdating = false
        }
      })

      onMounted(() => {
        if (IS_PRODUCTION || overmindInstance.mode.mode === MODE_SSR) return
        value.tree.stopTracking()
        overmindInstance.eventHub.emitAsync(EventType.COMPONENT_ADD, {
          componentId,
          componentInstanceId: value.componentInstanceId,
          name: '', // this.$options.name || '',
          paths: Array.from(value.tree.pathDependencies) as any,
        })
      })

      onBeforeUnmount(() => {
        if (overmindInstance.mode.mode === MODE_SSR) return

        overmindInstance.proxyStateTree.disposeTree(value.tree)
        if (IS_PRODUCTION) {
          return
        }

        overmindInstance.eventHub.emitAsync(EventType.COMPONENT_REMOVE, {
          componentId,
          componentInstanceId: value.componentInstanceId,
          name: '' // this.$options.name || '',
        })
      })

      value.tree.track(value.onUpdate)


      return state
    }
  }) as any
}

export interface ActionsHook<Config extends IConfiguration> {
  (): Ref<Overmind<Config>["actions"]>;
  <CB extends (actions: Overmind<Config>["actions"]) => object>(cb: CB): CB extends (actions: Overmind<Config>["actions"]) => infer O ? O extends object ? Ref<O> : never : never;
}

export function createActionsHook<Config extends IConfiguration>(): ActionsHook<Config> {
  return ((cb?: any): Overmind<Config>["actions"] => {
    const overmindInstance = inject<any>('overmind')

    return cb ? cb(overmindInstance.actions) : overmindInstance.actions
  }) as any
}

export interface EffectsHook<Config extends IConfiguration> {
  (): Ref<Overmind<Config>["effects"]>;
  <CB extends (effects: Overmind<Config>["effects"]) => object>(cb: CB): CB extends (effects: Overmind<Config>["effects"]) => infer O ? O extends object ? Ref<O> : never : never;
}

export function createEffectsHook<Config extends IConfiguration>(): EffectsHook<Config> {
  return ((cb?: any): Overmind<Config>["effects"] => {
    const overmindInstance = inject<any>('overmind')

    return cb ? cb(overmindInstance.effects) : overmindInstance.effects
  }) as any
}

export function createReactionHook<Config extends IConfiguration>() {
  return (): Overmind<Config>["reaction"] => {
    const overmindInstance = inject<any>('overmind')

    return overmindInstance.reaction
  }
}

export function createHooks<Config extends IConfiguration>() {
  return {
    state: createStateHook<Config>(),
    actions: createActionsHook<Config>(),
    effects: createEffectsHook<Config>(),
    reaction: createReactionHook<Config>()
  }
}