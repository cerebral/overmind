import ProxyStateTree from 'proxy-state-tree'
import { ActionBase, StopExecution } from 'action-chain'

type OperatorCallback<Effects, Value, NewValue = Value> = (
  effects: Effects,
  value: Value
) => NewValue | Promise<NewValue>

export interface IValueAction<
  State,
  Effects,
  InitialValue,
  Value = InitialValue
> extends Action<State, Effects, InitialValue, Value> {
  (value: InitialValue): Value
}

export interface INoValueAction<
  State,
  Effects,
  InitialValue,
  Value = InitialValue
> extends Action<State, Effects, InitialValue, Value> {
  (): Value
}

export default class Action<
  State,
  Effects,
  InitialValue,
  Value = InitialValue
> extends ActionBase<Effects> {
  private proxyStateTree: ProxyStateTree
  constructor(proxyStateTree, actionChain, initialActionId?, runOperators?) {
    super(actionChain, initialActionId, runOperators)
    this.proxyStateTree = proxyStateTree
  }
  fork: <Paths>(
    cb: (effects: Effects, value: Value) => keyof Paths,
    paths: Paths
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb, paths) => {
    const operator = (effects, value) => {
      const path = cb(effects, value)

      return (paths[path] as any).map(() => value)(value, effects, path)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'fork',
      cb.name,
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  mutation: (
    cb: (state: State, value: Value) => any
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb) => {
    const operator = (effects, value) => {
      this.proxyStateTree.startMutationTracking()
      cb(effects.state, value)
      const mutations = this.proxyStateTree.clearMutationTracking()
      this.getActionChain().emitAsync('mutations', {
        mutations,
        ...effects.__execution,
      })

      return value
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'mutation',
      cb.name,
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  do: (
    cb: (effects: Effects, value: Value) => void
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb) => {
    const operator = (effects, value) => {
      cb(effects, value)
      return value
    }

    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'do',
      cb.name,
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  map: <NewValue>(
    cb: (effects: Effects, value: Value) => NewValue | Promise<NewValue>
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, NewValue>
    : IValueAction<State, Effects, InitialValue, NewValue> = (cb) => {
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'map',
      cb.name,
      cb
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  try: <ResolveValue, RejectValue, FinallyValue, NewValue>(
    cb: OperatorCallback<Effects, Value, NewValue>,
    paths: {
      success: Action<
        State,
        Effects,
        ReturnType<OperatorCallback<Effects, Value, NewValue>>,
        ResolveValue
      >
      error: Action<
        State,
        Effects,
        ReturnType<OperatorCallback<Effects, Value, NewValue>>,
        RejectValue
      >
      finally?: Action<
        State,
        Effects,
        ReturnType<OperatorCallback<Effects, Value, NewValue>>,
        FinallyValue
      >
    }
  ) => [InitialValue] extends [void]
    ? INoValueAction<
        State,
        Effects,
        InitialValue,
        ResolveValue | RejectValue | FinallyValue
      >
    : IValueAction<
        State,
        Effects,
        InitialValue,
        ResolveValue | RejectValue | FinallyValue
      > = <ResolveValue, RejectValue, FinallyValue, NewValue>(cb, paths) => {
    const operator = (effects, value) => {
      return (cb(effects, value) as any)
        .then((promiseValue) => {
          return (paths.success as any)(promiseValue, effects, 'success')
        })
        .catch((error) => {
          return (paths.error as any)(error, effects, 'error')
        })
        .finally((promiseValue) => {
          return paths.finally
            ? (paths.finally as any)(promiseValue, effects, 'finally')
            : undefined
        })
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'try',
      cb.name,
      operator
    )

    return new Action<
      State,
      Effects,
      Value,
      ResolveValue | RejectValue | FinallyValue
    >(this.proxyStateTree, chain, initialActionId, runOperators) as any
  }
  when: <TrueValue, FalseValue>(
    cb: (effects: Effects, value: Value) => boolean,
    paths: {
      true: Action<State, Effects, Value, TrueValue>
      false: Action<State, Effects, Value, FalseValue>
    }
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, TrueValue | FalseValue>
    : IValueAction<State, Effects, InitialValue, TrueValue | FalseValue> = (
    cb,
    paths
  ) => {
    const operator = (effects, value) => {
      const isTrue = cb(effects, value)
      const path = isTrue ? paths.true : (paths.false as any)

      return path(value, effects, isTrue ? 'true' : 'false')
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'when',
      cb.name,
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  filter: (
    cb: (effects: Effects, value: Value) => boolean
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (cb) => {
    const operator = (effects, value) => {
      const result = cb(effects, value)

      if (result === true) {
        return value
      }

      return new StopExecution(value)
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'filter',
      cb.name,
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
  debounce: (
    timer: number
  ) => [InitialValue] extends [void]
    ? INoValueAction<State, Effects, InitialValue, Value>
    : IValueAction<State, Effects, InitialValue, Value> = (timer) => {
    let currentTimeout = null

    const operator = (_, value) => {
      return new Promise((resolve) => {
        if (currentTimeout) {
          currentTimeout()
        }
        const timeoutId = setTimeout(() => {
          resolve(value)
          currentTimeout = null
        }, timer)
        currentTimeout = () => {
          clearTimeout(timeoutId)
          resolve(new StopExecution(value))
        }
      })
    }
    const [chain, initialActionId, runOperators] = this.createOperatorResult(
      'debounce',
      '',
      operator
    )

    return new Action(
      this.proxyStateTree,
      chain,
      initialActionId,
      runOperators
    ) as any
  }
}
