import { Action, Configuration } from './'

type SubType<Base, Condition> = Pick<
  Base,
  { [Key in keyof Base]: Base[Key] extends Condition ? Key : never }[keyof Base]
>

interface ConfigurationWithModules extends Configuration {
  modules?: {
    [namespace: string]: {
      onInitialize?: any
      state?: any
      effects?: any
      actions?: any
      reactions?: any
    }
  }
}

type TState<Config extends ConfigurationWithModules> = [
  Config['state']
] extends [undefined]
  ? {
      [P in keyof SubType<Config['modules'], { state: {} }>]: SubType<
        Config['modules'],
        { state: {} }
      >[P]['state']
    }
  : [Config['modules']] extends [undefined]
    ? Config['state']
    : Config['state'] &
        {
          [P in keyof SubType<Config['modules'], { state: {} }>]: SubType<
            Config['modules'],
            { state: {} }
          >[P]['state']
        }

type TEffects<Config extends ConfigurationWithModules> = [
  Config['effects']
] extends [undefined]
  ? {
      [P in keyof SubType<Config['modules'], { effects: object }>]: SubType<
        Config['modules'],
        { effects: object }
      >[P]['effects']
    }
  : [Config['modules']] extends [undefined]
    ? Config['effects']
    : Config['effects'] &
        {
          [P in keyof SubType<Config['modules'], { effects: object }>]: SubType<
            Config['modules'],
            { effects: object }
          >[P]['effects']
        }

type TActions<Config extends ConfigurationWithModules> = [
  Config['actions']
] extends [undefined]
  ? {
      [P in keyof SubType<Config['modules'], { actions: object }>]: SubType<
        Config['modules'],
        { actions: object }
      >[P]['actions']
    }
  : [Config['modules']] extends [undefined]
    ? Config['actions']
    : Config['actions'] &
        {
          [P in keyof SubType<Config['modules'], { actions: object }>]: SubType<
            Config['modules'],
            { actions: object }
          >[P]['actions']
        }

function parseModule(
  result: { actions: any; effects: any; state: any; initializers: any[] },
  modName: string,
  mod: Configuration
) {
  const { actions, effects, onInitialize, state }: Configuration = mod

  if (actions) {
    result.actions[modName] = actions
  }
  if (effects) {
    result.effects[modName] = effects
  }
  if (state) {
    result.state[modName] = state
  }
  if (onInitialize) {
    result.initializers.push(onInitialize)
  }
}

export function modules<T extends ConfigurationWithModules>(
  configWithModules: T
): {
  onInitialize?: any
  state: TState<T>
  effects: TEffects<T>
  actions: TActions<T>
} {
  const result: any = {
    initializers: [],
    actions: configWithModules.actions || {},
    effects: configWithModules.effects || {},
    state: configWithModules.state || {},
  }
  const modules = configWithModules.modules || {}

  if (configWithModules.onInitialize) {
    result.initilizers.push(configWithModules.onInitialize)
  }

  Object.keys(modules).forEach((modName) => {
    parseModule(result, modName, modules[modName])
  })

  const onInitialize = (action) => action.parallel(result.initializers)

  return {
    onInitialize,
    actions: result.actions,
    effects: result.effects,
    state: result.state,
  }
}
