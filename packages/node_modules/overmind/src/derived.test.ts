import App, { TAction, TConfig, TDerive } from './'

type State = {
  foo: string
  upperFoo: string
}

describe('Derived', () => {
  test('should instantiate app with derived state', () => {
    const derived: Derive<string> = (state) => state.foo.toUpperCase()
    const state = {
      foo: 'bar',
      upperFoo: derived,
    }
    const config = {
      state,
    }

    type Config = TConfig<{
      state: typeof state
    }>

    type Derive<Value> = TDerive<Config, Value>

    const app = new App(config)

    expect(app.state.upperFoo).toEqual('BAR')
  })

  test('should track derived state', () => {
    let renderCount = 0
    const changeFoo: Action = ({ mutate }) =>
      mutate(({ state }) => (state.foo = 'bar2'))

    const derived: Derive<string> = (state: State) => state.foo.toUpperCase()

    const config = {
      state: {
        foo: 'bar',
        upperFoo: derived,
      },
      actions: {
        changeFoo,
      },
    }
    type Config = TConfig<{
      state: {
        foo: string
        upperFoo: string
      }
      actions: typeof config.actions
    }>
    type Action<Input = void, Output = any> = TAction<Config, Input, Output>
    type Derive<Value> = TDerive<Config, Value>

    const app = new App(config)
    function render() {
      const trackId = app.trackState()
      app.state.upperFoo
      return app.clearTrackState(trackId)
    }
    app.addMutationListener(render(), () => {
      renderCount++
    })
    app.actions.changeFoo()
    expect(app.state.upperFoo).toBe('BAR2')
    expect(renderCount).toBe(1)
  })
  test('should not require flush to flag as dirty', () => {
    expect.assertions(1)
    const changeFoo: Action = ({ map }) =>
      map(({ state }) => state.upperFoo)
        .mutate(({ state }) => (state.foo = 'bar2'))
        .run(({ state }) => {
          expect(state.upperFoo).toBe('BAR2')
        })

    const derived: Derive<string> = (state: State) => state.foo.toUpperCase()

    const config = {
      state: {
        foo: 'bar',
        upperFoo: derived,
      },
      actions: {
        changeFoo,
      },
    }
    type Config = TConfig<{
      state: {
        foo: string
        upperFoo: string
      }
      actions: typeof config.actions
    }>
    type Action<Input = void, Output = any> = TAction<Config, Input, Output>
    type Derive<Value> = TDerive<Config, Value>

    const app = new App(config)
    app.actions.changeFoo()
  })
})
