import { IS_PRODUCTION, IS_OPERATOR, makeStringifySafeMutations } from './utils'
import { EventType } from './internalTypes'
import { safeValue } from './Devtools'
import { IContext, IConfiguration } from './types'

export function startDebugOperator(type, arg, context) {
  if (IS_PRODUCTION) {
    return
  }
  const name =
    typeof arg === 'function' ? arg.displayName || arg.name : String(arg)

  context.execution.emit(EventType.OPERATOR_START, {
    ...context.execution,
    name,
    type,
  })
}

export function stopDebugOperator(
  context,
  value,
  details: {
    error?: Error
    isIntercepted?: boolean
    isSkipped?: boolean
  } = {}
) {
  if (IS_PRODUCTION) {
    return
  }

  const evaluatedDetails = {
    error: details.error ? details.error.message : undefined,
    isIntercepted: Boolean(details.isIntercepted),
    isSkipped: Boolean(details.isSkipped),
  }

  if (value instanceof Promise) {
    value
      .then((promiseValue) => {
        context.execution.emit(EventType.OPERATOR_END, {
          ...context.execution,
          result: safeValue(promiseValue),
          isAsync: true,
          ...evaluatedDetails,
        })
      })
      .catch(() => {
        // Make sure an error does not cause uncaught
      })
  } else {
    context.execution.emit(EventType.OPERATOR_END, {
      ...context.execution,
      result: safeValue(value),
      isAsync: false,
      ...evaluatedDetails,
    })
  }
}

export function createContext(context, value, path?) {
  if (IS_PRODUCTION) {
    return {
      ...context,
      value,
    }
  }

  const newExecution = {
    ...context.execution,
    operatorId: context.execution.getNextOperatorId(),
    path: path || context.execution.path,
  }

  return {
    ...context,
    value,
    execution: newExecution,
    effects: context.execution.trackEffects(newExecution),
  }
}

export function createNextPath(next) {
  if (IS_PRODUCTION) {
    return next
  }

  return (err, context) => {
    const newContext = {
      ...context,
      execution: {
        ...context.execution,
        path: context.execution.path.slice(
          0,
          context.execution.path.length - 1
        ),
      },
    }
    if (err) next(err, newContext)
    else next(null, newContext)
  }
}

export function createOperator<ThisConfig extends IConfiguration>(
  type: string,
  name: string,
  cb: (
    err: Error | null,
    context: IContext<ThisConfig>,
    value: any,
    next: (
      err: Error | null,
      value: any,
      options?: {
        path?: { name: string; operator: Function }
        isSkipped?: boolean
      }
    ) => void,
    final: (err: Error | null, value: any) => void
  ) => any
): any {
  const operator = (err, context, next, final) => {
    startDebugOperator(type, name, context)
    let asyncTimeout = setTimeout(() => {
      context.execution.emit(EventType.OPERATOR_ASYNC, {
        ...context.execution,
        isAsync: true,
      })
    })
    try {
      cb(
        err,
        {
          state: context.state,
          effects: context.effects,
          actions: context.actions,
        },
        context.value,
        (err, value, options = {}) => {
          clearTimeout(asyncTimeout)
          if (options.path) {
            const newContext = createContext(
              context,
              value,
              context.execution.path &&
                context.execution.path.concat(options.path.name)
            )
            const nextWithPath = createNextPath(next)
            options.path.operator(err, newContext, (...args) => {
              stopDebugOperator(context, args[1].value)
              nextWithPath(...args)
            })
          } else {
            stopDebugOperator(context, err || value, {
              isSkipped: err ? true : options.isSkipped,
            })
            next(err, createContext(context, value))
          }
        },
        (err, value) => {
          clearTimeout(asyncTimeout)
          stopDebugOperator(context, err || value, {
            isSkipped: Boolean(err),
            isIntercepted: !err,
          })
          final(err, createContext(context, value))
        }
      )
    } catch (error) {
      clearTimeout(asyncTimeout)
      stopDebugOperator(context, context.value, {
        error,
      })
      next(error, createContext(context, context.value))
    }
  }

  operator[IS_OPERATOR] = true

  return operator
}

export function createMutationOperator<ThisConfig extends IConfiguration>(
  type: string,
  name: string,
  cb: (
    err: Error | null,
    context: IContext<ThisConfig>,
    value: any,
    next: (
      err: Error | null,
      value: any,
      options?: {
        path?: { name: string; operator: Function }
        isSkipped?: boolean
      }
    ) => void,
    final: (err: Error | null, value: any) => void
  ) => any
): any {
  const operator = (err, context, next, final) => {
    startDebugOperator(type, name, context)
    const mutationTree = context.execution.getMutationTree()
    if (!IS_PRODUCTION) {
      mutationTree.onMutation((mutation) => {
        context.execution.emit(EventType.MUTATIONS, {
          ...context.execution,
          mutations: makeStringifySafeMutations([mutation]),
        })
      })
    }
    let asyncTimeout = setTimeout(() => {
      context.execution.emit(EventType.OPERATOR_ASYNC, {
        ...context.execution,
        isAsync: true,
      })
    })
    try {
      cb(
        err,
        {
          state: mutationTree.state,
          effects: context.effects,
          actions: context.actions,
        },
        IS_PRODUCTION
          ? context.value
          : context.execution.scopeValue(context.value, mutationTree),
        (err, value, options = {}) => {
          clearTimeout(asyncTimeout)
          stopDebugOperator(context, err || value, {
            isSkipped: err ? true : options.isSkipped,
          })
          next(err, createContext(context, value))
        },
        (err, value) => {
          clearTimeout(asyncTimeout)
          stopDebugOperator(context, err || value, {
            isSkipped: Boolean(err),
            isIntercepted: !err,
          })
          final(err, createContext(context, value))
        }
      )

      if (!IS_PRODUCTION) {
        let pendingFlush
        mutationTree.onMutation(() => {
          if (pendingFlush) {
            clearTimeout(pendingFlush)
          }
          pendingFlush = setTimeout(() => {
            const flushData = mutationTree.flush(true)

            if (flushData.mutations.length) {
              context.execution.send({
                type: 'flush',
                data: {
                  ...context.execution,
                  ...flushData,
                  mutations: makeStringifySafeMutations(flushData.mutations),
                },
              })
            }
          })
        })
      }
    } catch (error) {
      clearTimeout(asyncTimeout)
      stopDebugOperator(context, context.value, {
        error,
      })
      next(error, createContext(context, context.value))
    }
  }

  operator[IS_OPERATOR] = true

  return operator
}
