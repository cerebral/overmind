import { IConfiguration, IAction } from '../'
import { processState } from '../utils'

type SubType<Base, Condition> = Pick<
  Base,
  { [Key in keyof Base]: Base[Key] extends Condition ? Key : never }[keyof Base]
>

/*
  MERGE
*/

export function merge<A extends IConfiguration, B extends IConfiguration>(
  configA: A,
  configB: B
): A & B
export function merge<
  A extends IConfiguration,
  B extends IConfiguration,
  C extends IConfiguration
>(configA: A, configB: B, configC: C): A & B & C
export function merge<
  A extends IConfiguration,
  B extends IConfiguration,
  C extends IConfiguration,
  D extends IConfiguration
>(configA: A, configB: B, configC: C, configD: D): A & B & C & D
export function merge<
  A extends IConfiguration,
  B extends IConfiguration,
  C extends IConfiguration,
  D extends IConfiguration,
  E extends IConfiguration
>(configA: A, configB: B, configC: C, configD: D, configE: E): A & B & C & D & E
export function merge<
  A extends IConfiguration,
  B extends IConfiguration,
  C extends IConfiguration,
  D extends IConfiguration,
  E extends IConfiguration,
  F extends IConfiguration
>(
  configA: A,
  configB: B,
  configC: C,
  configD: D,
  configE: E,
  configF: F
): A & B & C & D & E & F
export function merge<
  A extends IConfiguration,
  B extends IConfiguration,
  C extends IConfiguration,
  D extends IConfiguration,
  E extends IConfiguration,
  F extends IConfiguration,
  G extends IConfiguration
>(
  configA: A,
  configB: B,
  configC: C,
  configD: D,
  configE: E,
  configF: F,
  configG: G
): A & B & C & D & E & F & G
export function merge<
  A extends IConfiguration,
  B extends IConfiguration,
  C extends IConfiguration,
  D extends IConfiguration,
  E extends IConfiguration,
  F extends IConfiguration,
  G extends IConfiguration,
  H extends IConfiguration
>(
  configA: A,
  configB: B,
  configC: C,
  configD: D,
  configE: E,
  configF: F,
  configG: G,
  configH: H
): A & B & C & D & E & F & G & H
export function merge<
  A extends IConfiguration,
  B extends IConfiguration,
  C extends IConfiguration,
  D extends IConfiguration,
  E extends IConfiguration,
  F extends IConfiguration,
  G extends IConfiguration,
  H extends IConfiguration,
  I extends IConfiguration
>(
  configA: A,
  configB: B,
  configC: C,
  configD: D,
  configE: E,
  configF: F,
  configG: G,
  configH: H,
  configI: I
): A & B & C & D & E & F & G & H & I
export function merge(...configurations: IConfiguration[]): IConfiguration {
  const initializers = configurations.reduce(
    (aggr, config) =>
      config.onInitialize ? aggr.concat(config.onInitialize) : aggr,
    [] as any[]
  )

  const reducedConfigurations = configurations.reduce(
    (aggr, config) => {
      const stateDuplicates = aggr.state
        ? Object.keys(aggr.state).some((key) =>
            config.state ? Object.keys(config.state).includes(key) : false
          )
        : false
      const actionsDuplicates = aggr.actions
        ? Object.keys(aggr.actions).some((key) =>
            config.actions ? Object.keys(config.actions).includes(key) : false
          )
        : false
      const effectsDuplicates = aggr.effects
        ? Object.keys(aggr.effects).some((key) =>
            config.effects ? Object.keys(config.effects).includes(key) : false
          )
        : false
      if (stateDuplicates) {
        throw new Error(
          'Merge conflict: at least one state definition contains a duplicate key'
        )
      }
      if (actionsDuplicates) {
        throw new Error(
          'Merge conflict: at least one actions definition contains a duplicate key'
        )
      }
      if (effectsDuplicates) {
        throw new Error(
          'Merge conflict: at least one effects definition contains a duplicate key'
        )
      }
      return {
        onInitialize: aggr.onInitialize,
        state: {
          ...aggr.state,
          ...config.state,
        },
        effects: {
          ...aggr.effects,
          ...config.effects,
        },
        actions: {
          ...aggr.actions,
          ...config.actions,
        },
      }
    },
    {
      onInitialize: initializers.length
        ? (context, value) =>
            Promise.all(initializers.map((cb) => cb(context, value)))
        : undefined,
      state: {},
      effects: {},
      actions: {},
    }
  )
  return reducedConfigurations
}

/*
  NAMESPACED
*/
interface NamespacedConfiguration {
  [namespace: string]: {
    onInitialize?: any
    state?: {}
    effects?: {}
    actions?: {}
    reactions?: {}
  }
}

function parseNamespacedConfig(
  result: { actions: any; effects: any; state: any; initializers: any[] },
  name: string,
  config: IConfiguration
) {
  const { actions, effects, onInitialize, state }: IConfiguration = config

  if (actions) {
    result.actions[name] = actions
  }
  if (effects) {
    result.effects[name] = effects
  }
  if (state) {
    result.state[name] = state
  }
  if (onInitialize) {
    result.initializers.push(onInitialize)
  }
}

export function namespaced<T extends NamespacedConfiguration>(
  namespaces: T
): {
  onInitialize?: any
  state: SubType<{ [P in keyof T]: T[P]['state'] }, object>
  effects: SubType<{ [P in keyof T]: T[P]['effects'] }, object>
  actions: SubType<{ [P in keyof T]: T[P]['actions'] }, object>
} {
  const result: any = {
    initializers: [],
    actions: {},
    effects: {},
    state: {},
  }

  Object.keys(namespaces).forEach((name) => {
    parseNamespacedConfig(result, name, namespaces[name])
  })

  return Object.assign(
    {
      actions: result.actions,
      effects: result.effects,
      state: result.state,
    },
    result.initializers.length
      ? {
          onInitialize: (context, app) =>
            Promise.all(result.initializers.map((cb) => cb(context, app))),
        }
      : {}
  )
}

interface LazyConfiguration {
  [namespace: string]: () => Promise<{
    onInitialize?: any
    state?: {}
    effects?: {}
    actions?: {}
    reactions?: {}
  }>
}

export function lazy<T extends LazyConfiguration, B = T>(
  configurations: T
): {
  onInitialize?: any
  state: SubType<
    {
      [P in keyof T]?: ReturnType<T[P]> extends Promise<infer U>
        ? U extends { state: any }
          ? U['state']
          : never
        : never
    },
    object
  >
  effects: SubType<
    {
      [P in keyof T]?: ReturnType<T[P]> extends Promise<infer U>
        ? U extends { effects: any }
          ? U['effects']
          : never
        : never
    },
    object
  > & {
    lazy: {
      loadConfig: (config: keyof T) => Promise<void>
    }
  }
  actions: SubType<
    {
      [P in keyof T]?: ReturnType<T[P]> extends Promise<infer U>
        ? U extends { actions: any }
          ? U['actions']
          : never
        : never
    },
    object
  > & {
    lazy: {
      loadConfig: IAction<any, keyof T>
    }
  }
} {
  let app
  return {
    onInitialize(_, value) {
      app = value
    },
    effects: {
      lazy: {
        loadConfig(config) {
          return app.actions.lazy.loadConfig(config)
        },
      },
    },
    actions: {
      lazy: {
        loadConfig({ state, ...rest }, key) {
          const configToLoad = configurations[key]

          return configToLoad().then((loadedConfig) => {
            const newConfig = namespaced({
              [key]: loadedConfig,
            })

            if (newConfig.state && newConfig.state[key])
              state[key] = processState(newConfig.state[key])
            if (newConfig.effects && newConfig.effects[key])
              app.effects[key] = newConfig.effects[key]
            if (newConfig.actions && newConfig.actions[key])
              app.actions[key] = app.getActions(newConfig.actions[key])
            if (newConfig.onInitialize)
              newConfig.onInitialize(
                {
                  state,
                  ...rest,
                },
                app
              )
          })
        },
      },
    },
  } as any
}
