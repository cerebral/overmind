import { ActionChain } from 'action-chain'
import { EventEmitter } from 'betsy'
import ProxyStateTree from 'proxy-state-tree'

import ActionClass, {
  Compose,
  INoValueAction,
  IValueAction,
  createOperators,
} from './Action'
import Derived from './derived'
import Devtools, { Message, safeValue } from './Devtools'
import { EventType, Events, Options } from './internalTypes'
import Reaction from './reaction'

const isPlainObject = require('is-plain-object')

export { modules } from './modules'

export { IValueAction, Compose, EventType }

export const log = (...objects: any[]) =>
  console.log(...objects.map((obj) => JSON.parse(JSON.stringify(obj))))

/*
  BASE TYPES
*/

export type Configuration = {
  onInitialize?: any
  state?: any
  effects?: any
  actions?: any
  reactions?: any
}

/*
  DECLARE MODULE TYPES
*/
export interface IState {}

export interface IEffects {}

export interface IActions {}

interface IApp {
  effects: IEffects
  state: StateNode<IState>
}

interface IOperationArgument<Value> extends IApp {
  value: Value
}

export type OnInitialize = (
  app: {
    state: IState
    actions: {
      [T in keyof IActions]: IActions[T] extends (...args: any[]) => any
        ? ReturnType<IActions[T]>
        : {
            [P in keyof IActions[T]]: IActions[T][P] extends (
              ...args: any[]
            ) => any
              ? ReturnType<IActions[T][P]>
              : undefined
          }
    }
    trackState(): number
    clearTrackState(id: number, cb?: () => void): Set<string>
    addMutationListener(paths, cb): () => void
  }
) => void

type StateNode<State extends object> = {
  [P in keyof State]: State[P] extends Derive<any>
    ? ReturnType<State[P]>
    : State[P] extends Array<any>
      ? State[P]
      : State[P] extends object ? StateNode<State[P]> : State[P]
}

export type TState<Config extends Configuration> = Config['state']

export type TEffects<Config extends Configuration> = Config['effects']

export type TActions<Config extends Configuration> = Config['actions']

export type Mutate<Value = any> = (
  arg: { state: IApp['state']; value: Value }
) => void

export namespace Operation {
  export type Map<Value, ReturnValue> = (
    arg: IOperationArgument<Value>
  ) => ReturnValue
  export type Filter<Value = any> = (arg: IOperationArgument<Value>) => boolean
  export type When<Value = any> = (arg: IOperationArgument<Value>) => boolean
  export type Run<Value = any> = (arg: IOperationArgument<Value>) => void
  export type Fork<Value = any> = (arg: IOperationArgument<Value>) => string
  export type Attempt<Value, ReturnValue> = (
    arg: IOperationArgument<Value>
  ) => ReturnValue
}

export type Action<InitialValue = void, ReturnValue = any> = Compose<
  IApp['state'],
  IApp['effects'],
  InitialValue,
  ReturnValue
>

export type TAction<
  InitialValue,
  ReturnValue = InitialValue,
  App extends { state: any; effects: any } = { state: any; effects: any }
> = Compose<App['state'], App['effects'], InitialValue, ReturnValue>

export type Reaction = (
  reaction: (
    getState: (state: IApp['state']) => any,
    action: TActionCaller<void, IApp>
  ) => any,
  action: ActionClass<IApp['state'], IApp['effects'], undefined, undefined>
) => any

export type TReaction<App extends { state: any; effects: any }> = (
  reaction: (
    getState: (state: App['state']) => any,
    action: INoValueAction<App['state'], App['effects'], undefined, undefined>
  ) => any,
  action: ActionClass<App['state'], App['effects'], undefined, undefined>
) => any

export type Derive<T> = (state: IApp['state']) => T

export type TDerive<T, App extends { state: any }> = (state: App['state']) => T

export type Compute<Input, Output> = (
  value: Input
) => (state: IApp['state']) => Output

export type TConfig<Config extends Configuration> = {
  onInitialize: any
  state: Config['state'] & {}
  effects: Config['effects'] & {}
  actions: Config['actions'] & {}
  reactions: any
}

export type TActionCreator<App> = {
  <InitialValue = void>(): TActionCaller<InitialValue, App>
}

export type TActionCaller<InitialValue, App> = [InitialValue] extends [void]
  ? INoValueAction<TConfig<App>['state'], TConfig<App>['effects'], InitialValue>
  : IValueAction<TConfig<App>['state'], TConfig<App>['effects'], InitialValue>

export type ActionCallback<App> = (action: TActionCreator<App>) => any

/*
  CLASS TYPES
*/

const hotReloadingCache = {}

export default class App<
  Config extends Configuration,
  EvalConfig extends TConfig<Config>
> {
  private proxyStateTree: ProxyStateTree
  initialized: Promise<any>
  eventHub: EventEmitter<Events>
  devtools: Devtools
  actions: {
    [T in keyof EvalConfig['actions']]: EvalConfig['actions'][T] extends Function
      ? ReturnType<EvalConfig['actions'][T]>
      : {
          [P in keyof EvalConfig['actions'][T]]: EvalConfig['actions'][T][P] extends Function
            ? ReturnType<EvalConfig['actions'][T][P]>
            : undefined
        }
  }
  state: StateNode<EvalConfig['state']>
  constructor(configuration: Config, options: Options = {}) {
    const name = options.name || 'MyApp'

    if (process.env.NODE_ENV === 'development') {
      if (hotReloadingCache[name]) {
        return hotReloadingCache[name]
      } else {
        hotReloadingCache[name] = this
      }
    }

    /*
      Set up an eventHub to trigger information from derived, computed and reactions
    */
    const eventHub = new EventEmitter<Events>()

    /*
      Create the proxy state tree instance with the state and a wrapper to expose
      the eventHub
    */
    const proxyStateTree = new ProxyStateTree(this.getState(configuration), {
      dynamicWrapper: (proxyStateTree, path, func) =>
        func(eventHub, proxyStateTree, path),
    })

    /*
      The action chain with the context configuration
    */
    const actionChain = new ActionChain(
      {
        state: proxyStateTree.get(),
        effects: configuration.effects,
      },
      { providerExceptions: ['state'] }
    )

    /*
      The action factory function
    */
    const operators = createOperators(proxyStateTree, actionChain)

    if (options.devtools !== false && typeof window !== 'undefined') {
      this.initializeDevtools(
        options.devtools,
        actionChain,
        eventHub,
        proxyStateTree
      )
    }

    this.initializeReactions(configuration, eventHub, proxyStateTree, operators)

    /*
      Identify when the state tree should flush out changes

      TODO:
        - How should I know when an operator is connected to a flushId?
        - Pass in operatorId on :async and set flushId directly?
        - Store operatorId on the flush and check?
    */
    actionChain.on('operator:async', (data) => {
      const flushData = proxyStateTree.flush()
      if (this.devtools && flushData.mutations.length) {
        this.devtools.send({
          type: 'flush',
          data: {
            ...data,
            ...flushData,
          },
        })
      }
    })
    actionChain.on('action:end', (data) => {
      const flushData = proxyStateTree.flush()
      if (this.devtools && flushData.mutations.length) {
        this.devtools.send({
          type: 'flush',
          data: {
            ...data,
            ...flushData,
          },
        })
      }
    })

    /*
      Expose the created actions
    */
    this.actions = this.getActions(configuration, operators)

    this.state = proxyStateTree.get()
    this.proxyStateTree = proxyStateTree
    this.eventHub = eventHub

    if (configuration.onInitialize) {
      const onInitialize = configuration.onInitialize(operators)
      onInitialize.displayName = 'onInitialize'
      this.initialized = Promise.resolve(onInitialize(this))
    } else {
      this.initialized = Promise.resolve(null)
    }
  }
  private initializeDevtools(host, actionChain, eventHub, proxyStateTree) {
    const devtools = new Devtools(
      typeof document === 'undefined' ? 'NoName' : document.title || 'NoName'
    )
    devtools.connect(
      host,
      (message: Message) => {
        // To use for communication from devtools app
      }
    )
    actionChain.on('action:start', (data) =>
      devtools.send({
        type: 'action:start',
        data: {
          ...data,
          value: safeValue(data.value),
        },
      })
    )
    actionChain.on('operator:start', (data) =>
      devtools.send({
        type: 'operator:start',
        data,
      })
    )
    actionChain.on('operator:end', (data) =>
      devtools.send({
        type: 'operator:end',
        data: {
          ...data,
          result: safeValue(data.result),
        },
      })
    )
    actionChain.on('action:end', (data) =>
      devtools.send({
        type: 'action:end',
        data,
      })
    )
    actionChain.on('effect', (data) =>
      devtools.send({
        type: 'effect',
        data,
      })
    )
    actionChain.on('mutations', (data) =>
      devtools.send({
        type: 'mutations',
        data,
      })
    )
    for (let type in EventType) {
      eventHub.on(EventType[type], (data) =>
        devtools.send({
          type: EventType[type],
          data,
        })
      )
    }
    // This message is always the first as it is passed synchronously, all other
    // events are emitted async
    devtools.send({
      type: 'init',
      data: {
        state: proxyStateTree.get(),
      },
    })
    this.devtools = devtools
  }
  private initializeReactions(
    configuration,
    eventHub,
    proxyStateTree,
    operators
  ) {
    const reactions = Object.keys(configuration.reactions || {}).reduce(
      (aggr, name) => {
        if (typeof configuration.reactions[name] === 'function') {
          return Object.assign(aggr, {
            [name]: configuration.reactions[name]((stateCb, action) => {
              action.displayName = name
              return [stateCb, action]
            }, operators),
          })
        }

        return Object.keys(configuration.reactions[name] || {}).reduce(
          (aggr, subName) =>
            Object.assign(aggr, {
              [name + '.' + subName]: configuration.reactions[name](
                (stateCb, action) => {
                  action.displayName = name + '.' + subName
                  return [stateCb, action]
                },
                operators
              ),
            }),
          {}
        )
      },
      {}
    )
    Object.keys(reactions).forEach((name) => {
      const reaction = new Reaction(eventHub, proxyStateTree, name)
      reaction.create(reactions[name][0], reactions[name][1])
    })
  }
  private getState(configuration: Configuration) {
    let state = {}
    if (configuration.state) {
      state = this.processState(configuration.state)
    }

    return state
  }
  private processState(state: {}) {
    return Object.keys(state).reduce((aggr, key) => {
      const value = state[key]
      if (isPlainObject(value)) {
        aggr[key] = this.processState(value)
      } else if (typeof value === 'function') {
        aggr[key] = new Derived(value)
      } else {
        aggr[key] = value
      }

      return aggr
    }, {})
  }
  private getActions(configuration: Configuration, operators) {
    let actions = {}
    if (configuration.actions) {
      actions = configuration.actions
    }

    const evaluatedActions = Object.keys(actions).reduce((aggr, name) => {
      if (typeof actions[name] === 'function') {
        return Object.assign(aggr, {
          [name]: actions[name](operators),
        })
      }

      return Object.assign(aggr, {
        [name]: Object.keys(actions[name] || {}).reduce(
          (aggr, subName) =>
            Object.assign(aggr, {
              [subName]: actions[name][subName](operators),
            }),
          {}
        ),
      })
    }, {}) as any

    if (this.devtools) {
      Object.keys(evaluatedActions).forEach((key) => {
        if (typeof evaluatedActions[key] === 'function') {
          evaluatedActions[key].displayName = key
        } else {
          Object.keys(evaluatedActions[key]).forEach((subKey) => {
            evaluatedActions[key][subKey].displayName = key + '.' + subKey
          })
        }
      })
    }

    return evaluatedActions
  }
  trackState() {
    return this.proxyStateTree.startPathsTracking()
  }
  clearTrackState(id: number, cb?: () => void) {
    return this.proxyStateTree.clearPathsTracking(id, cb)
  }
  addMutationListener(paths, cb) {
    return this.proxyStateTree.addFlushListener(paths, cb)
  }
  createReactionFactory(prefix: string) {
    const reactions = []
    const instance = this
    return {
      add(
        name: string,
        stateCb: (state: TConfig<Config>['state']) => any,
        cb: Function
      ) {
        const reaction = new Reaction(
          instance.eventHub,
          instance.proxyStateTree,
          prefix + '.' + name
        )
        reaction.create(stateCb, cb)

        reactions.push(reaction)
      },
      dispose() {
        reactions.forEach((reaction) => reaction.destroy())
        reactions.length = 0
      },
    }
  }
}
