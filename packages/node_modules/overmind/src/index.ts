import { ActionChain } from 'action-chain'
import { EventEmitter } from 'betsy'
import ProxyStateTree from 'proxy-state-tree'
import Devtools, { Message, safeValue } from './Devtools'
import ActionClass, {
  IValueAction,
  INoValueAction,
  Compose,
  createOperators,
} from './Action'
import Reaction from './reaction'
import {
  Events,
  EventType,
  Options,
  WithoutNeverDeep,
  EmptyIfNever,
} from './internalTypes'
// Needed due to Parcel + Webpack support
const isPlainObject = require('is-plain-object')

export { default as derive } from './derived'
export { default as compute } from './computed'

export { IValueAction, Compose, EventType }

export const log = (...objects: any[]) =>
  console.log(...objects.map((obj) => JSON.parse(JSON.stringify(obj))))

/*
  BASE TYPES
*/

export type Module = {
  onInitialize?: any
  state?: any
  effects?: any
  actions?: any
  reactions?: any
  plugins?: object
}

type Modules = {
  [namespace: string]: Module
}

export type Configuration = {
  onInitialize?: any
  state?: any
  effects?: any
  actions?: any
  reactions?: any
  modules?: Modules
  plugins?: object
}

/**
 * Plugins
 */

type PluginConfiguration = {
  onInitialize?: any
  state?: any
  effects?: any
  actions?: any
  reactions?: any
  plugins?: object
}

// We use a symbol so user can't create a FlatPlugin themself
const PLUGIN_TOKEN = Symbol('Plugin')

export type Plugin<Config extends PluginConfiguration> = {
  [PLUGIN_TOKEN]: true
  __state: TState<Config>
  __actions: TActions<Config>
  __effects: TEffects<Config>
}

type FlatPluginAny = {
  [PLUGIN_TOKEN]: true
  __state: any
  __actions: any
  __effects: any
}

export function plugin<Config extends PluginConfiguration>(
  config: Config | ((path: Array<string>) => Config)
): Plugin<Config> {
  return ((path) => {
    const resolvedConf = typeof config === 'function' ? config(path) : config
    resolvedConf[PLUGIN_TOKEN] = true
    return resolvedConf
  }) as any
}

/*
  DECLARE MODULE TYPES
*/
export interface IState {}

export interface IEffects {}

interface IApp extends IEffects {
  state: IState
}

/**
 * State
 */

type ExtractPluginState<T> = EmptyIfNever<
  WithoutNeverDeep<
    T extends FlatPluginAny
      ? (keyof T['__state'] extends never ? {} : T['__state'])
      : (T extends object ? { [K in keyof T]: ExtractPluginState<T[K]> } : T)
  >
>

type ExtractModulesState<T extends Modules> = {
  [K in keyof T]: [T[K]['state']] extends [undefined] ? {} : T[K]['state']
}

type Test = 'state' extends keyof { state: {} } ? true : false

// prettier-ignore
export type TState<Config extends Configuration> = (
  ([Config['state']] extends [undefined] ? {} : Config['state']) &
  ([Config['plugins']] extends [undefined] ? {} : ExtractPluginState<Config['plugins']>) &
  ([Config['modules']] extends [undefined] ? {} : ExtractModulesState<Config['modules']>)
)

/**
 * Actions
 */

export type ExtractPluginActions<T> = EmptyIfNever<
  WithoutNeverDeep<
    T extends FlatPluginAny
      ? (keyof T['__actions'] extends never ? never : T['__actions'])
      : (T extends object ? { [K in keyof T]: ExtractPluginActions<T[K]> } : T)
  >
>

type ExtractModulesActions<T extends Modules> = {
  [K in keyof T]: [T[K]['actions']] extends [undefined] ? {} : T[K]['actions']
}

// prettier-ignore
export type TActions<Config extends Configuration> = (
  ([Config['actions']] extends [undefined] ? {} : Config['actions']) &
  ([Config['plugins']] extends [undefined] ? {} : ExtractPluginActions<Config['plugins']>) &
  ([Config['modules']] extends [undefined] ? {} : ExtractModulesActions<Config['modules']>)
)

/**
 * Effects
 */

type ExtractPluginEffects<T> = EmptyIfNever<
  WithoutNeverDeep<
    T extends FlatPluginAny
      ? (keyof T['__effects'] extends never ? never : T['__effects'])
      : (T extends object ? { [K in keyof T]: ExtractPluginEffects<T[K]> } : T)
  >
>

type ExtractModulesEffects<T extends Modules> = {
  [K in keyof T]: [T[K]['effects']] extends [undefined] ? {} : T[K]['effects']
}

// prettier-ignore
export type TEffects<Config extends Configuration> = (
  ([Config['effects']] extends [undefined] ? {} : Config['effects']) &
  ([Config['plugins']] extends [undefined] ? {} : ExtractPluginEffects<Config['plugins']>) &
  ([Config['modules']] extends [undefined] ? {} : ExtractModulesEffects<Config['modules']>)
)

/**
 * Operations
 */

export type Mutate<Value = any> = (state: IApp['state'], value: Value) => void

export namespace Operation {
  export type Map<Value, ReturnValue> = (
    effects: IApp,
    value: Value
  ) => ReturnValue
  export type Filter<Value = any> = (effects: IApp, value: Value) => boolean
  export type When<Value = any> = (effects: IApp, value: Value) => boolean
  export type Run<Value = any> = (effects: IApp, value: Value) => void
  export type Fork<Value = any> = (effects: IApp, value: Value) => string
  export type Attempt<Value, ReturnValue> = (
    effects: IApp,
    value: Value
  ) => ReturnValue
}

/**
 * Action
 */

type ToCallable<Actions> = {
  [K in keyof Actions]: [Actions[K]] extends [Compose<any, any, any>]
    ? ReturnType<Actions[K]>
    : (keyof Actions[K] extends never ? never : ToCallable<Actions[K]>)
}

export type TAction<
  InitialValue,
  ReturnValue,
  Config extends Configuration
> = Compose<
  TState<Config>,
  TEffects<Config> & { state: TState<Config> },
  InitialValue,
  ReturnValue
>

export type Action<InitialValue = void, ReturnValue = any> = Compose<
  IApp['state'],
  IApp,
  InitialValue,
  ReturnValue
>

export type DynamicAction<InitialValue = void, ReturnValue = any> = Compose<
  any,
  any,
  InitialValue,
  ReturnValue
>

/**
 * Reaction, Derive & Compute
 */

export type Reaction = (
  reaction: (
    getState: (state: IApp['state']) => any,
    action: TActionCaller<void, IApp>
  ) => any,
  action: ActionClass<IApp['state'], IApp, undefined, undefined>
) => any

export type TReaction<Config extends Configuration> = (
  reaction: (
    getState: (state: TState<Config>) => any,
    action: INoValueAction<
      TState<Config>,
      TEffects<Config>,
      undefined,
      undefined
    >
  ) => any,
  action: ActionClass<TState<Config>, TEffects<Config>, undefined, undefined>
) => any

export type Derive<T> = (state: IApp['state']) => T

export type Compute<Input, Output> = (
  value: Input
) => (state: IApp['state']) => Output

export type TActionCreator<App> = {
  <InitialValue = void>(): TActionCaller<InitialValue, App>
}

export type TActionCaller<InitialValue, App> = [InitialValue] extends [void]
  ? INoValueAction<TState<App>, App, InitialValue>
  : IValueAction<TState<App>, App, InitialValue>

export type ActionCallback<App> = (action: TActionCreator<App>) => any

/*
  CLASS TYPES
*/

const hotReloadingCache = {}

export default class App<Config extends Configuration> {
  private proxyStateTree: ProxyStateTree
  eventHub: EventEmitter<Events>
  devtools: Devtools
  actions: ToCallable<TActions<Config>>
  state: TState<Config>
  constructor(configuration: Config, options: Options = {}) {
    const name = options.name || 'MyApp'

    if (process.env.NODE_ENV === 'development') {
      if (hotReloadingCache[name]) {
        return hotReloadingCache[name]
      } else {
        hotReloadingCache[name] = this
      }
    }

    /*
      Mutate modules into plugins
    */
    this.mutateModulesIntoPlugins(configuration)
    /*
      Mutate plugins functions into plugin objects
    */
    this.mutatePluginFunctionsIntoPlugins(configuration)

    /*
      Set up an eventHub to trigger information from derived, computed and reactions
    */
    const eventHub = new EventEmitter<Events>()

    /*
      Create the proxy state tree instance with the state and a wrapper to expose
      the eventHub
    */
    const proxyStateTree = new ProxyStateTree(this.getState(configuration), {
      dynamicWrapper: (proxyStateTree, path, func) =>
        func(eventHub, proxyStateTree, path),
    })

    /*
      The action chain with the context configuration
    */
    const actionChain = new ActionChain(
      Object.assign(
        { state: proxyStateTree.get() },
        this.getEffects(configuration)
      ),
      { providerExceptions: ['state'] }
    )

    /*
      The action factory function
    */
    const operators = createOperators(proxyStateTree, actionChain)

    if (options.devtools && typeof window !== 'undefined') {
      this.initializeDevtools(
        options.devtools,
        actionChain,
        eventHub,
        proxyStateTree
      )
    }

    this.initializeReactions(configuration, eventHub, proxyStateTree, operators)

    /*
      Identify when the state tree should flush out changes

      TODO:
        - How should I know when an operator is connected to a flushId?
        - Pass in operatorId on :async and set flushId directly?
        - Store operatorId on the flush and check?
    */
    actionChain.on('operator:async', (data) => {
      const flushData = proxyStateTree.flush()
      if (this.devtools && flushData.mutations.length) {
        this.devtools.send({
          type: 'flush',
          data: {
            ...data,
            ...flushData,
          },
        })
      }
    })
    actionChain.on('action:end', (data) => {
      const flushData = proxyStateTree.flush()
      if (this.devtools && flushData.mutations.length) {
        this.devtools.send({
          type: 'flush',
          data: {
            ...data,
            ...flushData,
          },
        })
      }
    })

    /*
      Expose the created actions
    */
    this.actions = this.getActions(configuration, operators)

    this.state = proxyStateTree.get()
    this.proxyStateTree = proxyStateTree
    this.eventHub = eventHub

    const initializers = this.getInitializers(configuration)

    if (!initializers.length) {
      return
    }

    const rootInitializer =
      initializers[0].name === 'onInitialize' ? initializers.shift() : null

    let onInitialize

    if (initializers.length) {
      onInitialize = operators.parallel(initializers)
    }

    if (rootInitializer) {
      onInitialize = operators.compose(rootInitializer)
    }

    // @ts-ignore
    onInitialize.displayName = 'onInitialize'
    onInitialize(undefined)
  }
  private setIn(target: any, path: Array<string>, value: any) {
    const parent = path.slice(0, -1).reduce((acc, key) => acc[key], target)
    parent[path[path.length - 1]] = value
  }
  private setInSafe(target: any, path: Array<string>, value: any) {
    const parent = path.slice(0, -1).reduce((acc, key) => {
      if (acc[key] === undefined) {
        acc[key] = {}
      }
      return acc
    }, target)
    parent[path[path.length - 1]] = value
  }
  private traversePlugins(config, onTraverse: (plugin, path) => void) {
    if (config.plugins) {
      const traverse = (val: any, path: Array<string>) => {
        if (val[PLUGIN_TOKEN] === true) {
          onTraverse(val, path)
          return
        }
        Object.keys(val).forEach((key) => {
          traverse(val[key], [...path, key])
        })
      }

      traverse(config.plugins, [])
    }
  }
  private mutateModulesIntoPlugins(config: Configuration) {
    if (!config.plugins) {
      config.plugins = {}
    }
    if (config.modules) {
      Object.keys(config.modules).forEach((namespace) => {
        const mod = config.modules[namespace]
        config.plugins[namespace] = plugin(mod)
      })
    }
  }
  private mutatePluginFunctionsIntoPlugins(config: Configuration) {
    const transformPlugin = (val: any, path: Array<string>) => {
      if (typeof val === 'function') {
        const resolved = val(path)
        if (resolved[PLUGIN_TOKEN] !== true) {
          console.warn(`Plugins must be wrapped in 'plugin()'`)
          return
        }
        this.setIn(config.plugins, path, resolved)
        if (resolved.plugins) {
          Object.keys(resolved.plugins).forEach((key) => {
            transformPlugin(resolved.plugins[key], [...path, key])
          })
        }
        return
      }
      if (!isPlainObject(val)) {
        console.warn(`Plugins must contains only 'plugins()' and plain objects`)
        return
      }
      Object.keys(val).forEach((key) => {
        transformPlugin(val[key], [...path, key])
      })
    }

    if (config.plugins) {
      transformPlugin(config.plugins, [])
    }
  }
  private initializeDevtools(host, actionChain, eventHub, proxyStateTree) {
    const devtools = new Devtools()
    devtools.connect(
      host,
      (message: Message) => {
        // To use for communication from devtools app
      }
    )
    actionChain.on('action:start', (data) =>
      devtools.send({
        type: 'action:start',
        data: {
          ...data,
          value: safeValue(data.value),
        },
      })
    )
    actionChain.on('operator:start', (data) =>
      devtools.send({
        type: 'operator:start',
        data,
      })
    )
    actionChain.on('operator:end', (data) =>
      devtools.send({
        type: 'operator:end',
        data: {
          ...data,
          result: safeValue(data.result),
        },
      })
    )
    actionChain.on('action:end', (data) =>
      devtools.send({
        type: 'action:end',
        data,
      })
    )
    actionChain.on('effect', (data) =>
      devtools.send({
        type: 'effect',
        data,
      })
    )
    actionChain.on('mutations', (data) =>
      devtools.send({
        type: 'mutations',
        data,
      })
    )
    for (let type in EventType) {
      eventHub.on(EventType[type], (data) =>
        devtools.send({
          type: EventType[type],
          data,
        })
      )
    }
    // This message is always the first as it is passed synchronously, all other
    // events are emitted async
    devtools.send({
      type: 'init',
      data: {
        state: proxyStateTree.get(),
      },
    })
    this.devtools = devtools
  }
  private initializeReactions(
    configuration,
    eventHub,
    proxyStateTree,
    operators
  ) {
    let reactions = {}
    const addReaction = (name, reaction) => {
      reactions[name] = reaction((stateCb, action) => {
        action.displayName = name
        return [stateCb, action]
      }, operators)
    }
    const addReactions = (reactions, path: Array<string> = []) => {
      Object.keys(reactions || {}).forEach((key) => {
        const val = reactions[key]
        if (typeof val === 'function') {
          addReaction([...path, key].join('.'), val)
          return
        }
        if (isPlainObject(val)) {
          Object.keys(val).forEach((subKey) => {
            addReactions(val[subKey], [...path, subKey])
          })
        }
      })
    }
    // basic reactions
    addReactions(configuration.reactions)
    // plugins
    this.traversePlugins(configuration, (plugin, path) => {
      addReactions(plugin.reactions, [...path])
    })

    Object.keys(reactions).forEach((name) => {
      const reaction = new Reaction(eventHub, proxyStateTree, name)
      reaction.create(reactions[name][0], reactions[name][1])
    })
  }
  private getState(configuration) {
    let state = {}
    // basic state
    if (configuration.state) {
      state = this.transformStateToPlainObject(configuration.state)
    }
    // plugins state
    this.traversePlugins(configuration, (plugin, path) => {
      if (plugin.state) {
        this.setInSafe(
          state,
          path,
          this.transformStateToPlainObject(plugin.state)
        )
      }
    })

    return state
  }
  private getEffects(configuration) {
    let effects = {}
    // basic state
    if (configuration.effects) {
      effects = configuration.effects
    }
    // plugins state
    this.traversePlugins(configuration, (plugin, path) => {
      if (plugin.effects) {
        this.setInSafe(effects, path, plugin.effects)
      }
    })

    return effects
  }
  private getInitializers(configuration) {
    let initializers = []
    if (configuration.onInitialize) {
      initializers.push(configuration.onInitialize)
    }
    this.traversePlugins(configuration, (plugin, path) => {
      if (plugin.onInitialize) {
        plugin.onInitialize.displayName = path.join('.') + '.onInitialize'
        initializers = initializers.concat(plugin.onInitialize)
      }
    })
    return initializers
  }
  private transformStateToPlainObject(state: {}) {
    return Object.keys(state).reduce((aggr, key) => {
      aggr[key] = state[key]

      return aggr
    }, {})
  }
  private getActions(configuration, operators) {
    let actions = {}
    if (configuration.actions) {
      actions = configuration.actions
    }
    this.traversePlugins(configuration, (plugin, path) => {
      if (plugin.actions) {
        this.setInSafe(actions, path, plugin.actions)
      }
    })

    const evaluatedActions = Object.keys(actions).reduce((aggr, name) => {
      if (typeof actions[name] === 'function') {
        return Object.assign(aggr, {
          [name]: actions[name](operators),
        })
      }

      return Object.assign(aggr, {
        [name]: Object.keys(actions[name] || {}).reduce(
          (aggr, subName) =>
            Object.assign(aggr, {
              [subName]: actions[name][subName](operators),
            }),
          {}
        ),
      })
    }, {}) as any

    if (this.devtools) {
      Object.keys(evaluatedActions).forEach((key) => {
        if (typeof evaluatedActions[key] === 'function') {
          evaluatedActions[key].displayName = key
        } else {
          Object.keys(evaluatedActions[key]).forEach((subKey) => {
            evaluatedActions[key][subKey].displayName = key + '.' + subKey
          })
        }
      })
    }

    return evaluatedActions
  }
  trackState() {
    return this.proxyStateTree.startPathsTracking()
  }
  clearTrackState(id: number, cb?: () => void) {
    return this.proxyStateTree.clearPathsTracking(id, cb)
  }
  addMutationListener(paths, cb) {
    return this.proxyStateTree.addMutationListener(paths, cb)
  }
  createReactionFactory(
    prefix: string
  ): {
    add: (
      name: string,
      stateCb: (state: TState<Config>) => any,
      cb: Function
    ) => void
    dispose: () => void
  } {
    const reactions = []
    const instance = this
    return {
      add(name: string, stateCb: (state: TState<Config>) => any, cb: Function) {
        const reaction = new Reaction(
          instance.eventHub,
          instance.proxyStateTree,
          prefix + '.' + name
        )
        reaction.create(stateCb, cb)

        reactions.push(reaction)
      },
      dispose() {
        reactions.forEach((reaction) => reaction.destroy())
        reactions.length = 0
      },
    }
  }
}
