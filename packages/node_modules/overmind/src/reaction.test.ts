import App, { TAction, TConfig, TReaction } from './'

describe('Reaction', () => {
  test('should instantiate app with reactions', () => {
    let hasRunReaction = false
    const foo: Action = ({ mutate }) =>
      mutate(({ state }) => (state.foo = 'bar2'))
    const react: Reaction = (reaction, { run }) =>
      reaction(
        (state) => state.foo,
        run(() => {
          hasRunReaction = true
        })
      )
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        foo,
      },
      reactions: {
        react,
      },
    }
    type Config = TConfig<{
      state: {
        foo: string
      }
      actions: typeof config.actions
      reactions: typeof config.reactions
    }>
    type Action<Input = void, Output = any> = TAction<Config, Input, Output>
    type Reaction = TReaction<Config>
    const app = new App(config)

    app.actions.foo()
    expect(hasRunReaction).toBe(true)
  })
  test('should react to nested changes', () => {
    let hasRunReaction = false
    const foo: Action = ({ mutate }) =>
      mutate(({ state }) => (state.foo[0].completed = true))
    const react: Reaction = (reaction, { run }) =>
      reaction(
        (state) => state.foo,
        run(() => {
          hasRunReaction = true
        })
      )
    const config = {
      state: {
        foo: [
          {
            completed: false,
          },
        ],
      },
      actions: {
        foo,
      },
      reactions: {
        react,
      },
    }
    type Config = TConfig<{
      state: {
        foo: typeof config.state.foo
      }
      actions: typeof config.actions
      reactions: typeof config.reactions
    }>
    type Action<Input = void, Output = any> = TAction<Config, Input, Output>
    type Reaction = TReaction<Config>
    const app = new App(config)
    app.actions.foo()
    expect(hasRunReaction).toBe(true)
  })
})
