import App, { TAction, TReaction, TActions, plugin } from './'

describe('Reaction', () => {
  test('should instantiate app with reactions', () => {
    let hasRunReaction = false
    const foo: Action = ({ mutate }) => mutate((state) => (state.foo = 'bar2'))
    const react: Reaction = (reaction, { run }) =>
      reaction(
        (state) => state.foo,
        run(() => {
          hasRunReaction = true
        })
      )
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        foo,
      },
      reactions: {
        react,
      },
    }
    type Config = {
      state: {
        foo: string
      }
      actions: typeof config.actions
      reactions: typeof config.reactions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    type Reaction = TReaction<Config>
    const app = new App(config)

    app.actions.foo()
    expect(hasRunReaction).toBe(true)
  })
  test('should instantiate reactions in module', () => {
    let hasRunReaction = false
    const foo: Action = ({ mutate }) => mutate((state) => (state.foo = 'bar2'))
    const react: Reaction = (reaction, { run }) =>
      reaction(
        (state) => state.foo,
        run(() => {
          hasRunReaction = true
        })
      )
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        foo,
      },
      modules: {
        myModule: {
          reactions: {
            react,
          },
        },
      },
    }
    type Config = {
      state: {
        foo: string
      }
      actions: typeof config.actions
      namespaces: typeof config.modules
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    type Reaction = TReaction<Config>
    const app = new App(config)

    app.actions.foo()
    expect(hasRunReaction).toBe(true)
  })
  test('should instantiate reactions in plugin', () => {
    let hasRunReaction = false
    const foo: Action = ({ mutate }) => mutate((state) => (state.foo = 'bar2'))
    const react: Reaction = (reaction, { run }) =>
      reaction(
        (state) => state.foo,
        run(() => {
          hasRunReaction = true
        })
      )
    const myPlugin = plugin({
      state: {
        yolo: true,
      },
      reactions: {
        react,
      },
    })
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        foo,
      },
      plugins: {
        myPlugin,
      },
    }
    type State = {
      foo: string
    }
    type Config = {
      state: State
      effects: any
      actions: typeof config.actions
      plugins: {
        myPlugin: typeof myPlugin
      }
    }
    type TheActions = TActions<Config>
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    type Reaction = TReaction<Config>
    const app = new App(config)

    app.actions.foo()
    expect(hasRunReaction).toBe(true)
  })
  test('should react to nested changes', () => {
    let hasRunReaction = false
    const foo: Action = ({ mutate }) =>
      mutate((state) => (state.foo[0].completed = true))
    const react: Reaction = (reaction, { run }) =>
      reaction(
        (state) => state.foo,
        run(() => {
          hasRunReaction = true
        })
      )
    const config = {
      state: {
        foo: [
          {
            completed: false,
          },
        ],
      },
      actions: {
        foo,
      },
      reactions: {
        react,
      },
    }
    type Config = {
      state: {
        foo: typeof config.state.foo
      }
      actions: typeof config.actions
      reactions: typeof config.reactions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    type Reaction = TReaction<Config>
    const app = new App(config)
    app.actions.foo()
    expect(hasRunReaction).toBe(true)
  })
})
