import App, { TAction, plugin } from './'

describe('Overmind', () => {
  test('should instantiate app with state', () => {
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        doThis: (action) => action.run(() => {}),
      },
      effects: {},
    }
    const app = new App(config)

    expect(app.state.foo).toEqual('bar')
  })
  test('should instantiate app with namespaces', () => {
    const fooAction: Action<string> = ({ run }) => run(() => {})

    const foo = {
      state: {
        foo: 'bar',
      },
      actions: {
        foo: fooAction,
      },
    }
    const bar = {
      state: {
        bar: 'baz',
      },
      effects: {
        hello: () => 'hello',
      },
      actions: {
        bar: fooAction,
      },
    }
    type Config = {
      modules: {
        foo: typeof foo
        bar: typeof bar
      }
    }

    type Action<Input = void, Output = any> = TAction<Input, Output, Config>

    const config = {
      modules: {
        foo,
        bar,
      },
    }

    const app = new App(config)

    expect(app.state.foo.foo).toEqual('bar')
    expect(app.state.bar.bar).toEqual('baz')
    expect(app.actions.foo.foo('mip')).toEqual('mip')
    expect(app.actions.bar.bar('bop')).toEqual('bop')
  })
})

describe('PLUGINS', () => {
  test('instantiate plugin state', () => {
    const myPlugin = plugin({
      state: {
        pluginState: true,
      },
    })
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        doThis: (action) => action.run(() => {}),
      },
      modules: {
        myModule: {
          state: {
            moduleState: true,
          },
        },
      },
      plugins: {
        myPlugin,
      },
    }
    const app = new App(config)
    expect(app.state).toEqual({
      foo: 'bar',
      myPlugin: { pluginState: true },
      myModule: { moduleState: true },
    })
    expect(app.state.myPlugin.pluginState).toBe(true)
    expect(app.state.myModule.moduleState).toBe(true)
  })
  test('create plugin actions', () => {
    const mockCallback = jest.fn()
    const myPlugin = plugin({
      actions: {
        doThis: (action) =>
          action.run(() => {
            mockCallback('plugin')
          }),
      },
    })
    const config = {
      actions: {
        doThis: (action) =>
          action.run(() => {
            mockCallback('not plugin')
          }),
      },
      plugins: {
        myPlugin,
      },
    }
    const app = new App(config)
    app.actions.doThis()
    expect(mockCallback.mock.calls.length).toBe(1)
    expect(mockCallback.mock.calls[0][0]).toBe('not plugin')
    app.actions.myPlugin.doThis()
    expect(mockCallback.mock.calls.length).toBe(2)
    expect(mockCallback.mock.calls[1][0]).toBe('plugin')
  })
  test('create plugin effects', () => {
    const mockCallback = jest.fn()
    const myPlugin = plugin({
      effects: {
        doThis: () => {
          mockCallback('plugin')
        },
      },
    })
    const callEffects: Action = (action) =>
      action.run((effects) => {
        effects.doThis()
        effects.myPlugin.doThis()
      })
    const config = {
      effects: {
        doThis: () => {
          mockCallback('not plugin')
        },
      },
      actions: {
        callEffects,
      },
      plugins: {
        myPlugin,
      },
    }
    type Config = {
      actions: typeof config.actions
      effects: {
        doThis: () => any
      }
      plugins: {
        myPlugin: typeof myPlugin
      }
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>

    const app = new App(config)
    app.actions.callEffects()

    expect(mockCallback.mock.calls.length).toBe(2)
    expect(mockCallback.mock.calls[0][0]).toBe('not plugin')
    expect(mockCallback.mock.calls[1][0]).toBe('plugin')
  })
})

describe('OPERATORS', () => {
  test('fork', () => {
    expect.assertions(2)
    let calledFoo = false
    const doThis: Action = ({ fork }) =>
      fork(() => 'foo', {
        foo: ({ run }) => run(() => (calledFoo = true)).map(() => '123'),
        bar: ({ map }) => map(() => 123),
      })
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>

    const app = new App(config)

    expect(app.actions.doThis()).toBe(undefined)
    expect(calledFoo).toBe(true)
  })
  test('mutate', () => {
    const doThis: Action = ({ mutate }) =>
      mutate((state) => (state.foo = 'bar2'))
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        doThis,
      },
    }
    type Config = {
      state: {
        foo: string
      }
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>

    const app = new App(config)

    expect(app.state.foo).toEqual('bar')
    app.actions.doThis()
    expect(app.state.foo).toEqual('bar2')
  })
  test('do', () => {
    expect.assertions(2)
    const doThis: Action<string> = ({ run }) =>
      run(({ foo }) => {
        expect(foo.bar()).toBe('baz')
        return Promise.resolve('bihihi')
      })
    const config = {
      state: {
        foo: 'bar',
      },
      effects: {
        foo: {
          bar: () => 'baz',
        },
      },
      actions: {
        doThis,
      },
    }
    type Config = {
      state: {
        foo: string
      }
      effects: {
        foo: typeof config.effects.foo
      }
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>

    const app = new App(config)
    return app.actions
      .doThis('foo')
      .then((result) => expect(result).toBe('foo'))
  })
  test('map', () => {
    expect.assertions(1)
    const doThis: Action<string> = ({ map }) =>
      map((_, value) => {
        return value.toUpperCase()
      })
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>

    const app = new App(config)

    expect(app.actions.doThis('foo')).toBe('FOO')
  })

  test('try - resolved', () => {
    expect.assertions(1)
    const doThis: Action = ({ attempt }) =>
      attempt(() => Promise.resolve(), {
        success: ({ map }) => map(() => 'foo'),
        error: ({ map }) => map(() => 'error'),
      })
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    const app = new App(config)

    return Promise.resolve(app.actions.doThis()).then((value) => {
      expect(value).toBe('foo')
    })
  })

  test('try - rejected', () => {
    expect.assertions(1)
    const doThis: Action = ({ attempt }) =>
      attempt(() => Promise.reject(new Error()), {
        success: ({ map }) => map(() => 'foo'),
        error: ({ map }) => map(() => 'bar'),
      })
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    const app = new App(config)
    return Promise.resolve(app.actions.doThis()).then((value) => {
      expect(value).toBe('bar')
    })
  })
  test('when - true', () => {
    expect.assertions(1)
    const doThis: Action = ({ when }) =>
      when(() => true, {
        true: ({ map }) => map(() => 'foo'),
        false: ({ run }) => run(() => {}),
      })
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    const app = new App(config)
    expect(app.actions.doThis()).toBe('foo')
  })

  test('when - false', () => {
    expect.assertions(1)
    const doThis: Action = ({ when }) =>
      when(() => false, {
        true: ({ map }) => map(() => 'foo'),
        false: ({ map }) => map(() => 'bar'),
      })
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    const app = new App(config)

    expect(app.actions.doThis()).toBe('bar')
  })

  test('filter - true', () => {
    expect.assertions(1)
    const doThis: Action<string> = ({ filter }) =>
      filter(() => true).map(() => 'bar')
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    const app = new App(config)
    expect(app.actions.doThis('foo')).toBe('bar')
  })
  test('filter - false', () => {
    expect.assertions(1)
    const doThis: Action<string> = ({ filter }) =>
      filter(() => false).map(() => 'bar')
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    const app = new App(config)

    expect(app.actions.doThis('foo')).toEqual({ value: 'foo' })
  })
  test('debounce', () => {
    expect.assertions(2)
    const start = Date.now()
    let end
    const doThis: Action = ({ debounce }) =>
      debounce(100)
        .run(() => {
          end = Date.now()
        })
        .map(() => 'foo')
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    const app = new App(config)

    return Promise.resolve(app.actions.doThis()).then((value) => {
      expect(value).toBe('foo')
      expect(end - start).toBeGreaterThanOrEqual(100)
    })
  })
  test('compose', () => {
    const mockCallback = jest.fn()
    const runMock: Action = ({ run }) =>
      run(() => {
        mockCallback()
      })
    const doThis: Action = ({ compose }) => compose(runMock)
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    const app = new App(config)
    app.actions.doThis()
    expect(mockCallback.mock.calls.length).toBe(1)
  })
  test('parallel', () => {
    const mockCallback = jest.fn()
    const runMock: Action = ({ run }) =>
      run(() => {
        mockCallback()
      })
    const doThis: Action = ({ parallel }) => parallel([runMock])
    const config = {
      actions: {
        doThis,
      },
    }
    type Config = {
      actions: typeof config.actions
    }
    type Action<Input = void, Output = any> = TAction<Input, Output, Config>
    const app = new App(config)
    app.actions.doThis()
    expect(mockCallback.mock.calls.length).toBe(1)
  })
})
