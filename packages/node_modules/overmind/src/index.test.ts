import App, { namespaces, Namespace, TAction } from './'

describe('Overmind', () => {
  test('should instantiate app with state', () => {
    const app = new App({
      state: {
        foo: 'bar',
      },
    })
    expect(app.state.foo).toEqual('bar')
  })
  test('should instantiate app with actions', () => {
    const app = new App({
      state: {},
      effects: {},
      actions: (action) => ({
        foo: action<string>(),
      }),
    })
    expect(app.actions.foo('bah')).toEqual('bah')
  })
  test('should instantiate app with namespaces', () => {
    const config = namespaces({
      foo: {
        state: {
          foo: 'bar',
        },
        actions: (action) => ({
          foo: action(),
        }),
      },
      bar: {
        state: {
          bar: 'baz',
        },
        actions: (action) => ({
          bar: action(),
        }),
      },
    })
    const app = new App(config)

    expect(app.state.foo.foo).toEqual('bar')
    expect(app.state.bar.bar).toEqual('baz')
    expect(app.actions.foo.foo('mip')).toEqual('mip')
    expect(app.actions.bar.bar('bop')).toEqual('bop')
  })
  test('should allow namespaced modules to be functions', () => {
    const fooNamespace = (namespace: Namespace) => {
      type State = {
        foo: string
      }
      type NamespacedState = {
        [namespace]: State
      }
      const state: State = {
        foo: 'bar',
      }

      type Action = TAction<NamespacedState, { state: NamespacedState }>

      return {
        state,
        actions: (action: Action) => ({
          foo: action<string>().map(
            ({ state }, value) => value + state[namespace].foo
          ),
        }),
      }
    }
    const config = namespaces({
      foo: fooNamespace,
    })
    const app = new App(config)

    expect(app.state.foo.foo).toEqual('bar')
    expect(app.actions.foo.foo('mip')).toEqual('mipbar')
  })
})

describe('OPERATORS', () => {
  test('fork', () => {
    expect.assertions(2)
    let calledFoo = false
    const app = new App({
      state: {},
      actions: (action) => {
        return {
          doThis: action().fork(() => 'foo', {
            foo: action()
              .do(() => (calledFoo = true))
              .map(() => '123'),
            bar: action().map(() => 123),
          }),
        }
      },
    })
    expect(app.actions.doThis()).toBe(undefined)
    expect(calledFoo).toBe(true)
  })
  test('mutate', () => {
    const app = new App({
      state: {
        foo: 'bar',
      },
      actions: (action) => ({
        doThis: action().mutation((state) => (state.foo = 'bar2')),
      }),
    })

    expect(app.state.foo).toEqual('bar')
    app.actions.doThis()
    expect(app.state.foo).toEqual('bar2')
  })
  test('do', () => {
    expect.assertions(2)
    const app = new App({
      state: {
        foo: 'bar',
      },
      effects: {
        foo: {
          bar: () => 'baz',
        },
      },
      actions: (action) => ({
        doThis: action<string>().do(({ foo }) => {
          expect(foo.bar()).toBe('baz')
        }),
      }),
    })
    expect(app.actions.doThis('foo')).toBe('foo')
  })
  test('map', () => {
    expect.assertions(1)
    const app = new App({
      state: {},
      actions: (action) => ({
        doThis: action<string>().map((_, value) => {
          return value.toUpperCase()
        }),
      }),
    })

    expect(app.actions.doThis('foo')).toBe('FOO')
  })

  test('try - resolved', () => {
    expect.assertions(1)
    const app = new App({
      state: {},
      actions: (action) => ({
        doThis: action().try(() => Promise.resolve(), {
          success: action().map(() => 'foo'),
          error: action().map(() => 'error'),
        }),
      }),
    })

    return Promise.resolve(app.actions.doThis()).then((value) => {
      expect(value).toBe('foo')
    })
  })

  test('try - rejected', () => {
    expect.assertions(1)
    const app = new App({
      state: {},
      actions: (action) => ({
        doThis: action().try(() => Promise.reject(new Error()), {
          success: action().map(() => 'foo'),
          error: action().map(() => 'bar'),
        }),
      }),
    })
    return Promise.resolve(app.actions.doThis()).then((value) => {
      expect(value).toBe('bar')
    })
  })

  test('try - finally', () => {
    expect.assertions(2)
    const app = new App({
      state: {
        finally: false,
      },
      actions: (action) => ({
        doThis: action().try(() => Promise.reject(new Error()), {
          success: action().map(() => 'foo'),
          error: action().map(() => 'bar'),
          finally: action().mutation((state) => (state.finally = true)),
        }),
      }),
    })
    return Promise.resolve(app.actions.doThis()).then((value) => {
      expect(value).toBe('bar')
      expect(app.state.finally).toBe(true)
    })
  })
  test('when - true', () => {
    expect.assertions(1)
    const app = new App({
      state: {},
      actions: (action) => ({
        doThis: action().when(() => true, {
          true: action().map(() => 'foo'),
          false: action(),
        }),
      }),
    })
    expect(app.actions.doThis()).toBe('foo')
  })

  test('when - false', () => {
    expect.assertions(1)
    const app = new App({
      state: {},
      actions: (action) => ({
        doThis: action().when(() => false, {
          true: action().map(() => 'foo'),
          false: action().map(() => 'bar'),
        }),
      }),
    })

    expect(app.actions.doThis()).toBe('bar')
  })

  test('filter - true', () => {
    expect.assertions(1)
    const app = new App({
      state: {},
      actions: (action) => ({
        doThis: action<string>()
          .filter(() => true)
          .map(() => 'bar'),
      }),
    })
    expect(app.actions.doThis('foo')).toBe('bar')
  })
  test('filter - false', () => {
    expect.assertions(1)
    const app = new App({
      state: {},
      actions: (action) => ({
        doThis: action<string>()
          .filter(() => false)
          .map(() => 'bar'),
      }),
    })

    expect(app.actions.doThis('foo')).toEqual({ value: 'foo' })
  })
  test('debounce', () => {
    expect.assertions(2)
    const start = Date.now()
    let end
    const app = new App({
      state: {},
      actions: (action) => ({
        doThis: action()
          .debounce(100)
          .do(() => {
            end = Date.now()
          })
          .map(() => 'foo'),
      }),
    })

    return Promise.resolve(app.actions.doThis()).then((value) => {
      expect(value).toBe('foo')
      expect(end - start).toBeGreaterThanOrEqual(100)
    })
  })
})
