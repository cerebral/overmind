import { EventEmitter } from 'betsy'
import ProxyStateTree from 'proxy-state-tree'
import { Events, EventType } from './'

type ComputedOptions = {
  cacheLimit?: number
}

type Cache = {
  isDirty: boolean
  proxyStateTreeListener: any
  value: any
  paths: Set<string>
  updateCount: number
}

export class Computed {
  private cacheLimit: number = 10
  private cacheKeys: Cache[] = []
  private cache: Map<any, Cache> = new Map()
  constructor(
    private cb: (config: any) => (state: object) => void,
    options: ComputedOptions = {}
  ) {
    this.cacheLimit = options.cacheLimit || this.cacheLimit
    return this.evaluate.bind(this)
  }
  evaluate(
    eventHub: EventEmitter<Events>,
    proxyStateTree: ProxyStateTree,
    path
  ) {
    return (config) => {
      let cache = this.cache.get(config)

      if (!cache) {
        cache = {
          isDirty: true,
          proxyStateTreeListener: null,
          value: undefined,
          paths: new Set<string>(),
          updateCount: 0,
        }
        this.cache.set(config, cache)
        this.cacheKeys.push(config)
        if (this.cacheKeys.length > this.cacheLimit) {
          const cacheKey = this.cacheKeys.shift()
          this.cache.get(cacheKey).proxyStateTreeListener.dispose()
          this.cache.delete(cacheKey)
        }
      }

      if (cache && cache.isDirty) {
        const trackId = proxyStateTree.startPathsTracking()
        cache.value = this.cb(config)(proxyStateTree.get())
        cache.isDirty = false
        cache.paths = proxyStateTree.clearPathsTracking(trackId)
        if (cache.proxyStateTreeListener) {
          cache.proxyStateTreeListener.update(cache.paths)
        } else {
          cache.proxyStateTreeListener = proxyStateTree.addMutationListener(
            cache.paths,
            (flushId) => {
              eventHub.emitAsync(EventType.COMPUTED_DIRTY, {
                path,
                flushId,
              })
              cache.isDirty = true
            }
          )
        }
        cache.updateCount++

        // Tracks the paths for the consumer of this derived value
        for (let path of cache.paths) {
          proxyStateTree.addTrackingPath(path)
        }

        eventHub.emitAsync(EventType.COMPUTED, {
          path,
          updateCount: cache.updateCount,
          limit: this.cacheLimit,
          cache: Array.from(this.cache.values()).map((cache) => ({
            value: cache.value,
            updateCount: cache.updateCount,
            paths: Array.from(cache.paths),
          })),
        })

        return cache.value
      } else if (cache) {
        return cache.value
      }
    }
  }
}

export default function compute<Config, NewValue>(
  cb: (config: Config) => (state: object) => NewValue,
  options?: ComputedOptions
): (config: Config) => NewValue {
  return new Computed(cb, options) as any
}
