import App, { compute } from './'

describe('Computed', () => {
  test('should instantiate app with computed', () => {
    type State = {
      foo: string
      test: (foo: number) => string
    }
    const state: State = {
      foo: 'bar',
      test: compute((foo: number) => (state: State) => state.foo + foo),
    }
    const app = new App({
      state,
    })
    expect(app.state.test(123)).toEqual('bar123')
  })
  test('should not recalculate when not dirty', () => {
    let runCount = 0
    type State = {
      foo: string
      test: (foo: number) => string
    }
    const state: State = {
      foo: 'bar',
      test: compute((foo: number) => (state: State) => {
        runCount++
        return state.foo + foo
      }),
    }
    const app = new App({
      state,
    })
    app.state.test(123)
    app.state.test(123)
    expect(runCount).toEqual(1)
  })
  test('should create new cache entry when args change', () => {
    let runCount = 0
    type State = {
      foo: string
      test: (foo: number) => string
    }
    const state: State = {
      foo: 'bar',
      test: compute((foo: number) => (state: State) => {
        runCount++
        return state.foo + foo
      }),
    }
    const app = new App({
      state,
    })
    app.state.test(123)
    app.state.test(321)
    expect(runCount).toEqual(2)
  })
  test('should flag as dirty when state changes', () => {
    let runCount = 0
    type State = {
      foo: string
      test: (foo: number) => string
    }
    const state: State = {
      foo: 'bar',
      test: compute((foo: number) => (state: State) => {
        runCount++
        return state.foo + foo
      }),
    }
    const app = new App({
      state,
      actions: (action) => ({
        changeFoo: action().mutation((state) => (state.foo = 'bar2')),
      }),
    })
    app.state.test(123)
    app.actions.changeFoo()
    expect(app.state.test(123)).toEqual('bar2123')
    expect(runCount).toEqual(2)
  })
  test('should use factory to adjust cache limit', () => {
    let runCount = 0
    type State = {
      foo: string
      test: (foo: number) => string
    }
    const state: State = {
      foo: 'bar',
      test: compute(
        (foo: number) => (state: State) => {
          runCount++
          return state.foo + foo
        },
        {
          cacheLimit: 1,
        }
      ),
    }
    const app = new App({
      state,
    })
    app.state.test(123)
    app.state.test(432)
    app.state.test(123)
    expect(runCount).toEqual(3)
  })
})
