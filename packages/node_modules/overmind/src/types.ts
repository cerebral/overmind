import { ResolveActions, ResolveState } from './internalTypes'
import { Overmind } from './'

/** ===== PUBLIC API
 */
export { EventType } from './internalTypes'

export type IConfiguration = {
  onInitialize?: any
  state?: {}
  effects?: {}
  actions?: {}
}

export type IState =
  | {
      [key: string]:
        | IState
        | string
        | IDerive<any, any, any>
        | number
        | boolean
        | object
        | null
        | undefined
    }
  | undefined

export interface IConfig<ThisConfig extends IConfiguration> {
  state: ThisConfig['state'] & {}
  actions: ThisConfig['actions'] & {}
  effects: ThisConfig['effects'] & {}
}

export type IContext<ThisConfig extends IConfiguration> = {
  state: ResolveState<ThisConfig['state']>
  actions: ResolveActions<ThisConfig['actions']>
  effects: ThisConfig['effects']
}

// DEPRECATED: Value is to be removed
export type AContext<ThisConfig extends IConfiguration, Value> = IContext<
  ThisConfig
> & { value: Value }

export interface IAction<ThisConfig extends IConfiguration, Value> {
  (context: AContext<ThisConfig, Value>, value: Value): any
}

// We do not type operators as their low level implementation, but rather
// how it is consumed by the developer
export type IOperator<
  ThisConfig extends IConfiguration,
  Input,
  Output = Input
> = (context: AContext<ThisConfig, Input>, value: Input) => Output

export type IDerive<
  ThisConfig extends IConfiguration,
  Parent extends IState,
  Value
> = (
  parent: ResolveState<Parent>,
  state: ResolveState<ThisConfig['state'] & {}>
) => Value

export interface IOnInitialize<ThisConfig extends IConfiguration> {
  (
    context: AContext<ThisConfig, Overmind<ThisConfig>>,
    value: Overmind<ThisConfig>
  ): void
}
