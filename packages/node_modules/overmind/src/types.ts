import ActionClass, { Compose, NoValueAction } from './Action'
import { ResolveActions, ResolveState, TBaseContext } from './internalTypes'

/** ===== PUBLIC API
 */
export { EventType } from './internalTypes'

export type Configuration = {
  onInitialize?: any
  state?: {}
  context?: {}
  actions?: {}
  reactions?: {}
}

export type BaseApp = {
  state: {}
  context: {}
  actions: {}
}

export interface TConfig<Config extends Configuration> {
  // Resolves `Derive` types in state.
  state: ResolveState<Config['state'] & {}>
  // Transform actions into callable functions.
  actions: ResolveActions<Config['actions'] & {}>
  context: Config['context'] & {}
}

export type TContext<App extends BaseApp, Value> = TBaseContext<App> & {
  value: Value
}

export type TAction<App extends BaseApp, Value, ReturnValue = Value> = Compose<
  TBaseContext<App>,
  Value,
  ReturnValue
>

export type TMutate<App extends BaseApp, Value = any> = (
  ctx: TContext<App, Value>
) => void

export type TDerive<App extends BaseApp, Value> = (state: App['state']) => Value

export type TReaction<App extends BaseApp> = (
  reaction: (
    getState: (state: App['state']) => any,
    action: NoValueAction<TBaseContext<App>, undefined>
  ) => any,
  action: ActionClass<TBaseContext<App>, undefined>
) => any

/** ===== DECLARE MODULE TYPES
 */

/** This type can be overwriten by app developers if they want to avoid
 * typing and then they can import `Action` and `Operation` directly from
 * overmind.
 */
type IApp = BaseApp

export type Action<Value = void, ReturnValue = any> = TAction<
  IApp,
  Value,
  ReturnValue
>

export type Mutate<Value = any> = TMutate<IApp, Value>

export type Context<Value> = TContext<IApp, Value>

export namespace Operation {
  export type Map<Value, ReturnValue = Value> = (
    ctx: Context<Value>
  ) => ReturnValue
  export type Filter<Value = any> = (ctx: Context<Value>) => boolean
  export type When<Value = any> = (ctx: Context<Value>) => boolean
  export type Run<Value = any> = (ctx: Context<Value>) => void
  export type Fork<Value = any> = (ctx: Context<Value>) => string
  export type Attempt<Value, ReturnValue> = (ctx: Context<Value>) => ReturnValue
}

export type Derive<Value> = TDerive<IApp, Value>

export type Reaction = TReaction<IApp>
