import {
  Overmind,
  pipe,
  map,
  forEach,
  filter,
  fork,
  when,
  IOperator,
  wait,
  debounce,
  mutate,
  parallel,
  IConfig,
  IAction,
  catchError,
  tryCatch,
  throttle,
  waitUntil,
} from './'

describe('OPERATORS', () => {
  test('map', () => {
    expect.assertions(1)
    const test: Operator<string> = pipe(
      map((_, value) => value.toUpperCase()),
      mutate(({ state }, value) => (state.foo = value))
    )

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test('foo').then(() => {
      expect(overmind.state.foo).toBe('FOO')
    })
  })

  test('map (async)', () => {
    expect.assertions(1)
    const test: Operator<string> = pipe(
      map((_, value) => Promise.resolve(value.toUpperCase())),
      mutate(({ state }, value) => (state.foo = value))
    )

    const state = {
      foo: 'bar',
    }

    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    return overmind.actions.test('foo').then(() => {
      expect(overmind.state.foo).toBe('FOO')
    })
  })

  test('forEach', () => {
    expect.assertions(1)
    let runCount = 0
    const operator: any = (_, val, next) => {
      runCount++
      next(null, val)
    }
    const test: Operator<string[]> = pipe(forEach(operator))

    const config = {
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    return overmind.actions.test(['foo']).then(() => {
      expect(runCount).toEqual(1)
    })
  })

  test('parallel', () => {
    expect.assertions(1)
    let runCount = 0
    const operator: any = (_, value, next) => {
      runCount++
      next(null, value)
    }
    const test: Operator<string> = pipe(parallel(operator, operator))

    const config = {
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    return overmind.actions.test('foo').then(() => {
      expect(runCount).toEqual(2)
    })
  })

  test('filter - truthy', () => {
    expect.assertions(1)
    const test: Operator<string> = pipe(
      filter((_, value) => value === 'foo'),
      map((_, value) => value.toUpperCase()),
      mutate(({ state }, value) => (state.foo = value))
    )

    const state = {
      foo: 'bar',
    }
    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test('foo').then(() => {
      expect(overmind.state.foo).toBe('FOO')
    })
  })

  test('filter - falsy', () => {
    const test: Operator<string> = pipe(
      filter((_, value) => value === 'bar'),
      map((_, value) => value.toUpperCase()),
      mutate(({ state }, value) => (state.foo = value))
    )

    const state = {
      foo: 'bar',
    }
    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test('foo').then(() => {
      expect(overmind.state.foo).toBe('bar')
    })
  })

  test('fork', () => {
    expect.assertions(1)
    enum Key {
      Foo = 'foo',
    }
    const test: Operator<string> = pipe(
      fork(() => Key.Foo, {
        [Key.Foo]: pipe(
          map((_, value) => {
            return value.toUpperCase()
          }),
          mutate(({ state }, value) => (state.foo = value))
        ),
      })
    )

    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test('foo').then(() => {
      expect(overmind.state.foo).toBe('FOO')
    })
  })

  test('when', () => {
    expect.assertions(1)
    const test: Operator<string, string | number> = pipe(
      when(() => true, {
        true: pipe(
          map((_, value) => value.toUpperCase()),
          mutate(({ state }, value) => (state.foo = value))
        ),
        false: pipe(
          map((_, value) => Number(value)),
          mutate(({ state }, value) => (state.number = value))
        ),
      })
    )

    const state = {
      foo: 'bar',
      number: 0,
    }
    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    return overmind.actions.test('foo').then(() => {
      expect(overmind.state.foo).toBe('FOO')
    })
  })

  test('wait', () => {
    expect.assertions(1)
    const runTime = Date.now()
    const test: Operator = wait(500)

    const config = {
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    interface Action<Input = void> extends IAction<Config, Input> {}

    return overmind.actions.test().then(() => {
      expect(Date.now() - runTime).toBeGreaterThanOrEqual(500)
    })
  })

  test('debounce', () => {
    expect.assertions(1)
    const test: Operator = pipe(
      debounce(100),
      mutate(({ state }) => state.runCount++)
    )
    const state = {
      runCount: 0,
    }
    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return Promise.all([overmind.actions.test(), overmind.actions.test()]).then(
      () => {
        expect(overmind.state.runCount).toBe(1)
      }
    )
  })
  test('throttle', () => {
    expect.assertions(1)
    const test: Operator = pipe(
      throttle(0),
      mutate(({ state }) => state.runCount++)
    )
    const state = {
      runCount: 0,
    }
    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return Promise.all([overmind.actions.test(), overmind.actions.test()]).then(
      () => {
        expect(overmind.state.runCount).toBe(1)
      }
    )
  })

  test('catchError', () => {
    expect.assertions(3)
    const test: Operator<string> = pipe(
      mutate(() => {
        throw new Error('wut?!?')
      }),
      mutate(({ state }) => {
        state.runCount++
      }),
      catchError(({ state }, error) => {
        state.error = error.message

        return 'hm'
      }),
      mutate(({ state }, value) => {
        state.foo = value
      })
    )
    const state = {
      runCount: 0,
      foo: 'bar',
      error: '',
    }
    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test('baz').then(() => {
      expect(overmind.state.runCount).toBe(0)
      expect(overmind.state.error).toBe('wut?!?')
      expect(overmind.state.foo).toBe('hm')
    })
  })
  test('tryCatch - resolves', () => {
    expect.assertions(1)
    const test: Operator<string> = tryCatch({
      try: mutate(({ state }, value) => {
        state.foo = value
      }),
      catch: mutate(() => {}),
    })
    const state = {
      foo: 'bar',
    }
    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test('baz').then(() => {
      expect(overmind.state.foo).toBe('baz')
    })
  })
  test('tryCatch - fails', () => {
    expect.assertions(1)
    const test: Operator<string> = pipe(
      tryCatch({
        try: mutate(() => {
          throw new Error('ehm')
        }),
        catch: mutate(({ state }, value) => {
          state.foo = value.message
        }),
      })
    )
    const state = {
      foo: 'bar',
    }
    const config = {
      state,
      actions: {
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    return overmind.actions.test('baz').then(() => {
      expect(overmind.state.foo).toBe('ehm')
    })
  })
  test('waitUntil', () => {
    expect.assertions(1)
    const increaseCount: Operator = pipe(
      mutate(({ state }) => state.runCount++)
    )
    const test: Operator = pipe(
      waitUntil((state) => state.runCount === 1),
      mutate(({ state }) => (state.hasRun = true))
    )
    const state = {
      runCount: 0,
      hasRun: false,
    }
    const config = {
      state,
      actions: {
        increaseCount,
        test,
      },
    }
    const overmind = new Overmind(config)

    type Config = IConfig<typeof config>

    interface Operator<Input = void, Output = Input>
      extends IOperator<Config, Input, Output> {}

    setTimeout(() => {
      overmind.actions.increaseCount()
    }, 0)

    return overmind.actions.test().then(() => {
      expect(overmind.state.runCount).toBe(1)
    })
  })
})
