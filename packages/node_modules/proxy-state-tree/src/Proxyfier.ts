import { TTree, ITrackStateTree, IMutationTree } from './types'
import isPlainObject from 'is-plain-obj'

export const IS_PROXY = Symbol('IS_PROXY')
export const PATH = Symbol('PATH')
export const VALUE = Symbol('VALUE')
export const CACHED_PROXY = Symbol('CACHED_PROXY')

const arrayMutations = new Set([
  'push',
  'shift',
  'pop',
  'unshift',
  'splice',
  'reverse',
  'sort',
  'copyWithin',
])

export class Proxifier {
  private proxyCache = {}
  private disposeRemoveProxy: () => void
  constructor(private tree: TTree) {
    this.disposeRemoveProxy = tree.master.onRemoveProxy(this.removeProxies)
  }
  private concat(path, prop) {
    return path ? path + '.' + prop : prop
  }
  addProxyToCache(path: string, proxy: any) {
    const pathArray = path.split('.')
    let currentCache = this.proxyCache
    const length = pathArray.length
    const keyIndex = length - 1

    for (let x = 0; x < length; x++) {
      const key = pathArray[x]

      if (!currentCache[key]) {
        currentCache[key] = {}
      }

      if (x === keyIndex) {
        currentCache[key][CACHED_PROXY] = proxy
      } else {
        currentCache = currentCache[key]
      }
    }

    return proxy
  }

  getProxyFromCache(path: string) {
    const pathArray = path.split('.')
    let currentCache = this.proxyCache
    const length = pathArray.length
    const keyIndex = length - 1

    for (let x = 0; x < length; x++) {
      const key = pathArray[x]

      if (!currentCache[key]) {
        return null
      }

      if (x === keyIndex) {
        return currentCache[key][CACHED_PROXY]
      } else {
        currentCache = currentCache[key]
      }
    }
  }

  removeProxies = (path: string) => {
    const pathArray = path.split('.')
    let currentCache = this.proxyCache
    const length = pathArray.length
    const keyIndex = length - 1

    for (let x = 0; x < length; x++) {
      const key = pathArray[x]

      if (!currentCache[key]) {
        return null
      }

      if (x === keyIndex) {
        delete currentCache[key]
      } else {
        currentCache = currentCache[key]
      }
    }
  }

  ensureMutationTrackingIsEnabled(path) {
    if (this.tree.master.options.devmode && !this.tree.canMutate()) {
      throw new Error(
        `proxy-state-tree - You are mutating the path "${path}", but it is not allowed`
      )
    }
  }

  isDefaultProxifier() {
    return this.tree.proxifier === this.tree.master.proxifier
  }

  ensureValueDosntExistInStateTreeElsewhere(value) {
    if (value && value[IS_PROXY] === true) {
      throw new Error(
        `proxy-state-tree - You are trying to insert a value that already exists in the state tree on path "${
          value[PATH]
        }"`
      )
    }
  }

  trackPath(path: string) {
    if (!this.tree.canTrack()) {
      return
    }

    if (this.isDefaultProxifier()) {
      const trackStateTree = this.tree.master.currentTree as ITrackStateTree<
        any
      >

      if (!trackStateTree) {
        return
      }

      trackStateTree.addTrackingPath(path)
    } else {
      ;(this.tree as ITrackStateTree<any>).addTrackingPath(path)
    }
  }
  // With tracking trees we want to ensure that we are always
  // on the currently tracked tree. This ensures when we access
  // a tracking proxy that is not part of the current tracking tree (pass as prop)
  // we move the ownership to the current tracker
  getTrackingTree() {
    if (this.tree.master.currentTree && this.isDefaultProxifier()) {
      return this.tree.master.currentTree
    }

    if (!this.tree.canTrack()) {
      return null
    }

    if (this.tree.canTrack()) {
      return this.tree
    }

    return null
  }
  getMutationTree() {
    return this.tree.master.mutationTree || (this.tree as IMutationTree<any>)
  }
  private createArrayProxy(value, path) {
    var proxifier = this

    return (
      this.getProxyFromCache(path) ||
      this.addProxyToCache(
        path,
        new Proxy(value, {
          get(target, prop) {
            if (prop === IS_PROXY) return true
            if (prop === PATH) return path
            if (prop === VALUE) return value

            if (
              prop === 'length' ||
              (typeof target[prop] === 'function' &&
                !arrayMutations.has(String(prop))) ||
              typeof prop === 'symbol'
            ) {
              return target[prop]
            }

            const trackingTree = proxifier.getTrackingTree()
            const nestedPath = proxifier.concat(path, prop)

            trackingTree && trackingTree.proxifier.trackPath(nestedPath)

            const method = String(prop)

            if (arrayMutations.has(method)) {
              // On POP we can optimally remove cached proxy by removing the specific one
              // that was removed. If it is a PUSH, we do not have to remove anything, as
              // existing proxies stays the same
              if (method === 'pop') {
                proxifier.tree.master.removeProxy(nestedPath)
              } else if (method !== 'push') {
                proxifier.tree.master.removeProxy(path)
              }

              proxifier.ensureMutationTrackingIsEnabled(nestedPath)
              return (...args) => {
                const mutationTree = proxifier.getMutationTree()

                mutationTree.addMutation({
                  method,
                  path: path,
                  args: args,
                })

                return target[prop](...args)
              }
            }

            if (target[prop] === undefined) {
              return undefined
            }

            return proxifier.proxify(target[prop], nestedPath)
          },
          set(target, prop, value) {
            const nestedPath = proxifier.concat(path, prop)

            proxifier.ensureMutationTrackingIsEnabled(nestedPath)
            proxifier.ensureValueDosntExistInStateTreeElsewhere(value)

            const mutationTree = proxifier.getMutationTree()

            if (isPlainObject(target[prop])) {
              proxifier.tree.master.removeProxy(nestedPath)
            }

            mutationTree.addMutation({
              method: 'set',
              path: nestedPath,
              args: [value],
            })

            return Reflect.set(target, prop, value)
          },
        })
      )
    )
  }

  private createObjectProxy(value, path) {
    const proxifier = this

    return (
      this.getProxyFromCache(path) ||
      this.addProxyToCache(
        path,
        new Proxy(value, {
          get(target, prop) {
            if (prop === IS_PROXY) return true
            if (prop === PATH) return path
            if (prop === VALUE) return value

            if (typeof prop === 'symbol' || prop in Object.prototype)
              return target[prop]

            const descriptor = Object.getOwnPropertyDescriptor(target, prop)

            if (descriptor && 'get' in descriptor) {
              const value = descriptor.get.call(
                proxifier.getProxyFromCache(path)
              )

              if (
                proxifier.tree.master.options.devmode &&
                proxifier.tree.master.options.onGetter
              ) {
                proxifier.tree.master.options.onGetter(
                  proxifier.concat(path, prop),
                  value
                )
              }

              return value
            }

            const trackingTree = proxifier.getTrackingTree()
            const targetValue = target[prop]
            const nestedPath = proxifier.concat(path, prop)

            trackingTree && trackingTree.proxifier.trackPath(nestedPath)

            if (typeof targetValue === 'function') {
              const dynamicValue = proxifier.tree.master.options.dynamicWrapper
                ? proxifier.tree.master.options.dynamicWrapper(
                    proxifier.tree,
                    nestedPath,
                    targetValue
                  )
                : targetValue(proxifier.tree, nestedPath)

              if (dynamicValue && dynamicValue[IS_PROXY]) {
                return proxifier.proxify(
                  dynamicValue[VALUE],
                  dynamicValue[PATH]
                )
              }

              return dynamicValue
            }

            if (targetValue === undefined) {
              return undefined
            }

            return proxifier.proxify(targetValue, nestedPath)
          },
          set(target, prop, value) {
            const nestedPath = proxifier.concat(path, prop)

            proxifier.ensureMutationTrackingIsEnabled(nestedPath)
            proxifier.ensureValueDosntExistInStateTreeElsewhere(value)

            if (isPlainObject(target[prop]) || Array.isArray(target[prop])) {
              proxifier.tree.master.removeProxy(nestedPath)
            }

            let objectChangePath

            if (!(prop in target)) {
              objectChangePath = path
            }

            const mutationTree = proxifier.getMutationTree()

            mutationTree.addMutation(
              {
                method: 'set',
                path: nestedPath,
                args: [value],
              },
              objectChangePath
            )

            if (typeof value === 'function') {
              return Reflect.set(target, prop, () => value)
            }

            return Reflect.set(target, prop, value)
          },
          deleteProperty(target, prop) {
            const nestedPath = proxifier.concat(path, prop)

            proxifier.ensureMutationTrackingIsEnabled(nestedPath)

            if (isPlainObject(target[prop]) || Array.isArray(target[prop])) {
              proxifier.tree.master.removeProxy(nestedPath)
            }

            let objectChangePath
            if (prop in target) {
              objectChangePath = path
            }

            const mutationTree = proxifier.getMutationTree()

            mutationTree.addMutation(
              {
                method: 'unset',
                path: nestedPath,
                args: [],
              },
              objectChangePath
            )

            delete target[prop]

            return true
          },
        })
      )
    )
  }
  proxify(value: any, path: string) {
    if (value) {
      if (value[IS_PROXY] && String(value[PATH]) !== String(path)) {
        return this.proxify(value[VALUE], path)
      } else if (value[IS_PROXY]) {
        return value
      } else if (isPlainObject(value)) {
        return this.createObjectProxy(value, path)
      } else if (Array.isArray(value)) {
        return this.createArrayProxy(value, path)
      }
    }

    return value
  }
  destroy() {
    this.proxyCache = null
  }
}
