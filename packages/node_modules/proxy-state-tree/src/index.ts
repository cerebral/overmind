import proxify, { IS_PROXY, STATUS } from './proxify'
const isPlainObject = require('is-plain-object')

export type Options = {
  devmode?: boolean
  dynamicWrapper?: Function
}

export type Mutation = {
  method: string
  path: string
  args: any[]
}

class ProxyStateTree {
  state: object
  options: Options
  pathDependencies: object
  globalDependencies: Set<Function>
  objectChanges: Set<string>
  mutations: Mutation[]
  currentMutations: Mutation[]
  paths: Set<string>[]
  status: STATUS
  proxy: any
  currentFlushId: number
  constructor(state: object, options: Options = {}) {
    if (!isPlainObject(state)) {
      throw new Error('You have to pass a plain object to the Proxy State Tree')
    }

    if (typeof options.devmode === 'undefined') {
      options.devmode = true
    }

    this.state = state
    this.options = options
    this.pathDependencies = {}
    this.globalDependencies = new Set()
    this.mutations = []
    this.currentMutations = []
    this.paths = []
    this.objectChanges = new Set()
    this.status = STATUS.IDLE
    this.proxy = proxify(this, state)
    this.currentFlushId = 0
  }
  get() {
    return this.proxy
  }
  addTrackingPath(path) {
    if (this.status === STATUS.TRACKING_PATHS) {
      this.paths[this.paths.length - 1].add(path)
    }
  }
  flush() {
    const paths = new Set()
    const pathCallbacksToCall = new Set()
    const mutations = this.mutations.slice()
    const flushId = this.currentFlushId++

    for (let objectChange of this.objectChanges) {
      if (this.pathDependencies[objectChange]) {
        paths.add(objectChange)
      }
    }

    for (let mutation in this.mutations) {
      paths.add(this.mutations[mutation].path)
    }

    // Sort so that parent paths are called first
    const sortedPaths = Array.from(paths).sort()

    for (let path of sortedPaths) {
      if (this.pathDependencies[path]) {
        for (let callback of this.pathDependencies[path]) {
          pathCallbacksToCall.add(callback)
        }
      }
    }

    for (let callback of pathCallbacksToCall) {
      callback(flushId)
    }

    paths.clear()
    pathCallbacksToCall.clear()
    this.mutations.length = 0
    this.objectChanges.clear()

    for (let globalDependency of this.globalDependencies) {
      globalDependency(mutations, flushId)
    }

    return {
      mutations,
      flushId,
    }
  }
  startMutationTracking() {
    if (this.status !== STATUS.IDLE) {
      throw new Error(
        `You can not start tracking mutations unless idle. The status is: ${
          this.status
        }`
      )
    }
    this.status = STATUS.TRACKING_MUTATIONS
  }
  clearMutationTracking() {
    const currentMutations = this.currentMutations.slice()

    this.status = STATUS.IDLE
    this.currentMutations.length = 0
    this.mutations = this.mutations.concat(currentMutations)

    return currentMutations
  }
  startPathsTracking() {
    if (this.status === STATUS.TRACKING_MUTATIONS) {
      throw new Error(
        `You can not start tracking paths when tracking mutations.`
      )
    }

    this.status = STATUS.TRACKING_PATHS

    return this.paths.push(new Set()) - 1
  }
  clearPathsTracking(index: number) {
    if (index !== this.paths.length - 1) {
      throw new Error(
        'Nested path tracking requires you to stop the nested path tracker before the outer'
      )
    }
    const pathSet = this.paths.pop()

    if (!this.paths.length) {
      this.status = STATUS.IDLE
    }

    return pathSet
  }
  addMutationListener(cb: (mutations: Mutation[], flushId: number) => void)
  addMutationListener(initialPaths: Set<string>, cb: (flushId: number) => void)
  addMutationListener() {
    if (arguments.length === 1) {
      const cb = arguments[0]
      const globalDependencies = this.globalDependencies
      globalDependencies.add(cb)

      return {
        dispose() {
          globalDependencies.delete(cb)
        },
      }
    } else {
      const initialPaths = arguments[0]
      const cb = arguments[1]
      const pathDependencies = this.pathDependencies
      let currentStringPaths = initialPaths

      for (let currentStringPath of currentStringPaths) {
        pathDependencies[currentStringPath] = pathDependencies[
          currentStringPath
        ]
          ? pathDependencies[currentStringPath].add(cb)
          : new Set([cb])
      }

      return {
        update(newStringPaths: Set<string>) {
          for (let currentStringPath of currentStringPaths) {
            if (!newStringPaths.has(currentStringPath)) {
              pathDependencies[currentStringPath].delete(cb)
            }
          }

          for (let newStringPath of newStringPaths) {
            if (!currentStringPaths.has(newStringPath)) {
              pathDependencies[newStringPath] = pathDependencies[newStringPath]
                ? pathDependencies[newStringPath].add(cb)
                : new Set([cb])
            }
          }

          currentStringPaths = newStringPaths
        },
        dispose() {
          for (let currentStringPath of currentStringPaths) {
            pathDependencies[currentStringPath].delete(cb)

            if (pathDependencies[currentStringPath].size === 0) {
              delete pathDependencies[currentStringPath]
            }
          }
        },
      }
    }
  }
}

export { IS_PROXY }
export default ProxyStateTree
