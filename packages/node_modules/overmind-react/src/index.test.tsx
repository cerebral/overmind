import { IAction, Overmind, createOvermindMock } from 'overmind'
import * as React from 'react'
import * as renderer from 'react-test-renderer'

import { IConnect, Provider, createConnect, createHook } from './'

describe('React', () => {
  test('should connect state and actions to stateless components', () => {
    expect.assertions(2)
    let didCallAction = false
    const doThis: Action = () => {
      didCallAction = true
    }

    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        doThis,
      },
    }

    type IConfig = {
      state: {
        foo: typeof config.state.foo
      }
      actions: {
        doThis: typeof doThis
      }
    }

    const app = new Overmind(config)

    interface Action<Input = void, Output = void | Promise<void>>
      extends IAction<IConfig, Input, Output> {}

    const connect = createConnect()

    const Component: React.SFC<IConnect<IConfig>> = ({ overmind }) => {
      overmind.actions.doThis()
      return <h1>{overmind.state.foo}</h1>
    }
    const ConnectedComponent = connect(Component)
    const tree = renderer
      .create(
        <Provider value={app}>
          <ConnectedComponent />
        </Provider>
      )
      .toJSON()

    expect(didCallAction).toBe(true)
    expect(tree).toMatchSnapshot()
  })

  test('should connect actions and state to class components', () => {
    expect.assertions(2)
    let didCallAction = false
    const doThis: Action = () => {
      didCallAction = true
    }
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        doThis,
      },
    }

    type IConfig = {
      state: {
        foo: typeof config.state.foo
      }
      actions: {
        doThis: typeof doThis
      }
    }

    const app = new Overmind(config)

    interface Action<Input = void, Output = void | Promise<void>>
      extends IAction<IConfig, Input, Output> {}

    const connect = createConnect()

    class Component extends React.Component<IConnect<IConfig>> {
      componentDidMount() {
        this.props.overmind.actions.doThis()
      }
      render() {
        const { overmind } = this.props

        return <h1>{overmind.state.foo}</h1>
      }
    }
    const ConnectedComponent = connect(Component)
    const tree = renderer
      .create(
        <Provider value={app}>
          <ConnectedComponent />
        </Provider>
      )
      .toJSON()

    expect(didCallAction).toBe(true)
    expect(tree).toMatchSnapshot()
  })

  test('should allow using component as normal, even when not connected', () => {
    expect.assertions(2)
    const config = {
      state: {
        foo: 'bar',
      },
    }

    const app = new Overmind(config)

    const connect = createConnect()

    class Component extends React.Component<IConnect<typeof config>> {
      render() {
        const { overmind } = this.props

        return <h1>{overmind ? overmind.state.foo : 'nada'}</h1>
      }
    }
    const ConnectedComponent = connect(Component)
    const tree = renderer
      .create(
        <Provider value={app}>
          <ConnectedComponent />
        </Provider>
      )
      .toJSON()
    const tree2 = renderer.create(<Component overmind={null as any} />).toJSON()

    expect(tree).toMatchSnapshot()
    expect(tree2).toMatchSnapshot()
  })

  test('should preserve component name', () => {
    const app = new Overmind({})
    const connect = createConnect<{}>()

    class FooComponent extends React.Component<IConnect<{}>> {
      render() {
        return <h1>hop</h1>
      }
    }
    function BarComponent() {
      return <div />
    }

    const ConnectedFoo = connect(FooComponent)
    const ConnectedBar = connect(BarComponent)
    expect(ConnectedFoo.name).toBe('ConnectFooComponent')
    expect(ConnectedBar.name).toBe('ConnectBarComponent')
  })

  test('should allow using shouldComponentUpdate', () => {
    let renderCount = 0

    const doThis: Action = ({ state }) => {
      state.foo = 'bar2'
    }
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        doThis,
      },
    }

    type IConfig = {
      state: {
        foo: typeof config.state.foo
      }
      actions: {
        doThis: typeof doThis
      }
    }

    const app = new Overmind(config)

    interface Action<Input = void> extends IAction<IConfig, Input> {}

    const connect = createConnect()

    class FooComponent extends React.Component<IConnect<typeof config>> {
      shouldComponentUpdate(nextProps) {
        return this.props.overmind !== nextProps.overmind
      }
      render() {
        renderCount++
        return <h1>{this.props.overmind.state.foo}</h1>
      }
    }

    const ConnectedFoo = connect(FooComponent)

    const tree = renderer
      .create(
        <Provider value={app}>
          <ConnectedFoo />
        </Provider>
      )
      .toJSON()

    expect(renderCount).toBe(1)

    app.actions.doThis()

    expect(renderCount).toBe(2)
  })
  test('should allow using hooks', () => {
    let renderCount = 0

    const doThis: Action = ({ state }) => {
      state.foo = 'bar2'
    }
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        doThis,
      },
    }

    type IConfig = {
      state: {
        foo: typeof config.state.foo
      }
      actions: {
        doThis: typeof doThis
      }
    }

    const app = new Overmind(config)

    interface Action<Input = void> extends IAction<IConfig, Input> {}

    const useOvermind = createHook<typeof app>()

    const FooComponent: React.FunctionComponent = () => {
      const { state } = useOvermind()
      renderCount++

      return <h1>{state.foo}</h1>
    }

    const tree = renderer
      .create(
        <Provider value={app}>
          <FooComponent />
        </Provider>
      )
      .toJSON()

    expect(renderCount).toBe(1)

    renderer.act(() => {
      app.actions.doThis()
    })

    expect(renderCount).toBe(2)
    expect(tree).toMatchSnapshot()
  })
  test('should allow using mocked Overmind', () => {
    let renderCount = 0

    const doThis: Action = ({ state }) => {
      state.foo = 'bar2'
    }
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        doThis,
      },
    }

    type IConfig = {
      state: {
        foo: typeof config.state.foo
      }
      actions: {
        doThis: typeof doThis
      }
    }

    interface Action<Input = void> extends IAction<IConfig, Input> {}

    const useOvermind = createHook<typeof config>()

    const FooComponent: React.FunctionComponent = () => {
      const { state } = useOvermind()
      renderCount++

      return <h1>{state.foo}</h1>
    }

    const mock = createOvermindMock(config)
    const tree = renderer
      .create(
        <Provider value={mock}>
          <FooComponent />
        </Provider>
      )
      .toJSON()

    expect(renderCount).toBe(1)
    expect(tree).toMatchSnapshot()
  })
  test('should be able to use Provider with connect', () => {
    let renderCount = 0

    const doThis: Action = ({ state }) => {
      state.foo = 'bar2'
    }
    const config = {
      state: {
        foo: 'bar',
      },
      actions: {
        doThis,
      },
    }

    type IConfig = {
      state: {
        foo: typeof config.state.foo
      }
      actions: {
        doThis: typeof doThis
      }
    }

    interface Action<Input = void> extends IAction<IConfig, Input> {}

    interface Connect extends IConnect<IConfig> {}

    const connect = createConnect()

    const FooComponent: React.FunctionComponent<Connect> = ({ overmind }) => {
      renderCount++

      return <h1>{overmind.state.foo}</h1>
    }

    const ConnectedFooComponent = connect(FooComponent)

    const mock = createOvermindMock(config)
    const tree = renderer
      .create(
        <Provider value={mock}>
          <ConnectedFooComponent />
        </Provider>
      )
      .toJSON()

    expect(renderCount).toBe(1)
    expect(tree).toMatchSnapshot()
  })
  test('should throw an error without provider', () => {
    expect.assertions(1)

    const config = {
      state: {
        foo: 'bar',
      },
    }

    type IConfig = {
      state: {
        foo: typeof config.state.foo
      }
    }

    const useApp = createHook<IConfig>();

    const FooComponent = () => {
      const { state } = useApp();

      return <h1>{state.foo}</h1>
    }

    expect(() => {
      renderer
        .create(
          <FooComponent />
        )
        .toJSON()
    }).toThrow(Error)
  })
  test('should forward ref', () => {
    const app = new Overmind({})

    const connect = createConnect<{}>()

    const expected = "bar"

    class ForwardComponent extends React.Component<IConnect<{}>> {
      foo = expected
      render() {
        return <h1>{this.foo}</h1>
      }
    }

    const ConnectedFoo = connect(ForwardComponent)

    const ref = React.createRef<ForwardComponent>();

    const tree = renderer
      .create(
        <Provider value={app}>
          <ConnectedFoo ref={ref} />
        </Provider>
      )
      .toJSON()

    expect(ref.current?.foo).toBe(expected)
    expect(tree).toMatchSnapshot()
  })
})
